digraph {
graph ["layout"="dot","rankdir"="LR"];
"phone-tree.parse.ast/dispatches" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 35\n(defn dispatches\n  \"Returns a seq of potential dispatch vals for an `ast` node, in decreasing\n  precedence:\n\n  - the java method for an `:instance-call` or `:static-call` node\n    (as a symbol: 'java.class/method-name)\n  - the clojure function for an `:invoke` node\n    (as a symbol: 'clojure.ns/fn-name)\n  - the clojure function or macro in the original form, for any node\n    (as a symbol: 'clojure.ns/fn-name)\n  - the ast `:op`, for any node (a keyword)\"\n  [{:keys [op] :as ast}]\n  (->> [;; java.class/method-name\n        (when (#{:instance-call :static-call} op)\n          (when-let [cls (:class ast)]\n            (symbol (.getName cls) (str (:method ast)))))\n        ;; clojure.ns/fn-name\n        (when (= :invoke op)\n          (some-> ast :fn :var util/var->symbol))\n        ;; first var in the original form (a macro or function)\n        (some-> (first-form-var ast) util/var->symbol)\n        ;; raw op\n        op]\n       (filter identity)\n       (distinct)))","label"="phone-tree.parse.ast/dispatches"];
"phone-tree.parse.ast/parse _reify" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 51\n(defmethod ast/parse :reify\n  [ast]\n  (record-reify! (:class-name ast) (meta (:form ast)))\n  ;; call the default method\n  ((get-method ast/parse :default) ast))","label"="phone-tree.parse.ast/parse :reify"];
"clojure.tools.namespace.dir/scan-all" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.namespace.dir/scan-all"];
"phone-tree.graph/read-lines" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 108\n(def read-lines (memoize (comp vec str/split-lines slurp)))","label"="phone-tree.graph/read-lines"];
"phone-tree.graph/edge-with-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 21\n(defn edge-with-attrs [g edge]\n  [(lg/src edge) (lg/dest edge) (or (la/attrs g edge) {})])","label"="phone-tree.graph/edge-with-attrs"];
"phone-tree.parse.ast/parse _instance-call" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/interop.clj, line 9\n(defmethod ast/parse :instance-call\n  [{:keys [instance method args] :as ast}]\n  (let [cls (or (guess-class instance)\n                (guess-class ast)\n                java.lang.Object)\n        ;; method is already munged if this is from a clojure protocol\n        method-sym (symbol (.getName cls) (str method))]\n    (concat ;; edge to the protocol fn itself\n            (build/edge ast {:dest method-sym})\n            ;; args are parsed as children of the enclosing scope\n            (ast/parse-children instance args))))","label"="phone-tree.parse.ast/parse :instance-call"];
"phone-tree.graph/node-with-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 18\n(defn node-with-attrs [g n]\n  [n (or (la/attrs g n) {})])","label"="phone-tree.graph/node-with-attrs"];
"phone-tree.log/debug" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 22\n(def debug (partial log :debug))","label"="phone-tree.log/debug"];
"phone-tree.core/parse-cli" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 114\n(defn parse-cli [args]\n  (let [{:keys [options arguments errors summary]} (cli/parse-opts args cli-options)]\n    (cond\n      (:help options)\n      {:exit 0, :message (usage summary)}\n      errors\n      {:exit 1, :message (str/join \"\\n\" errors)}\n      :else\n      (conform-options options arguments))))","label"="phone-tree.core/parse-cli"];
"phone-tree.parse.class/reify-prefix" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 22\n(defn reify-prefix\n  \"Returns the prefix for a reify class.\n\n  Reify classes are inner classes of the namespace (and optionally, the\n  function) they are defined in. e.g.:\n\n    my.ns$reify__123456\n    my.ns$my_fn$reify__123456\n\n  The prefix is everything up to and including \\\"reify\\\"\"\n  [cls]\n  (some->> cls .getName (re-find #\"^.*\\$reify\")))","label"="phone-tree.parse.class/reify-prefix"];
"phone-tree.core/exclude-clojure-regex" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 27\n(def exclude-clojure-regex #\"clojure\\.(core/|lang\\.).*\")","label"="phone-tree.core/exclude-clojure-regex"];
"phone-tree.parse.ast/ast-resolve" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 17\n(defn ast-resolve\n  \"Like ns-resolve, but using the :ns from the ast's :env\"\n  [ast sym]\n  (when-let [env-ns (some-> ast :env :ns find-ns)]\n    (when (symbol? sym)\n      (ns-resolve env-ns sym))))","label"="phone-tree.parse.ast/ast-resolve"];
"phone-tree.core/print-graph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 149\n(defn print-graph [g opts]\n  (case (:format opts)\n    :edn (prn (uber/ubergraph->edn g))\n    :dot (println (graph/->dot g (:dot-attr opts)))\n    :html (println (html/render (graph/->json g)))\n    :csv (println (graph/->csv g))))","label"="phone-tree.core/print-graph"];
"phone-tree.redef/try-require" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/redef.clj, line 15\n(defn try-require [& args]\n  (try\n    (apply require args)\n    true\n    (catch java.io.FileNotFoundException _\n      false)))","label"="phone-tree.redef/try-require"];
"phone-tree.parse.ast/parse _static-call" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/interop.clj, line 41\n(defmethod ast/parse :static-call\n  [{:keys [class method args] :as ast}]\n  ;; java static method invocations\n  (let [cls (or (guess-class ast)\n                class\n                java.lang.Object)\n        method-sym (symbol (.getName cls) (str method))]\n    (concat ;; edge to the method\n            (build/edge ast {:dest method-sym})\n            ;; args are parsed as children of the enclosing scope\n            (ast/parse-children args))))","label"="phone-tree.parse.ast/parse :static-call"];
"clojure.string/join" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.string/join"];
"loom.graph/add-edges" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/add-edges"];
"phone-tree.parse.interop" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/interop.clj, line 1\n(ns phone-tree.parse.interop\n  \"Interop call parsing.\"\n  (:require [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]\n            [phone-tree.parse.class :refer [guess-class]]))","label"="phone-tree.parse.interop"];
"loom.graph/nodes" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/nodes"];
"phone-tree.parse.ast/parse-children" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 81\n(defn parse-children\n  \"Parses any combination of ast nodes or sequences of ast nodes.\"\n  [& children]\n  (mapcat parse (flatten children)))","label"="phone-tree.parse.ast/parse-children"];
"phone-tree.core/conform-options" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 108\n(defn conform-options [opts args]\n  (cond-> opts\n    (seq args) (assoc :source-paths args)\n    (not (:include-clojure opts)) (update :exclude-node (fnil conj []) exclude-clojure-regex)\n    (not (:include-java opts)) (update :exclude-node (fnil conj []) exclude-java-regex)))","label"="phone-tree.core/conform-options"];
"phone-tree.core/usage" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 100\n(defn usage [options-summary]\n  (->> [\"Usage: lein phone-tree [options] [source-paths]\"\n        \"\"\n        \"Options:\"\n        options-summary\n        \"\"]\n       (str/join \"\\n\")))","label"="phone-tree.core/usage"];
"phone-tree.util" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/util.clj, line 1\n(ns phone-tree.util)","label"="phone-tree.util"];
"phone-tree.parse.ast/parse (quote clojure.core/defprotocol)" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 58\n(defmethod ast/parse 'clojure.core/defprotocol\n  [{:keys [result] :as ast}]\n  (when-let [protocol (some-> (ast/ast-resolve ast result) var-get)]\n    ;; pull all the methods off the protocol definition itself\n    (flatten\n     (for [k (keys (:method-builders protocol))]\n       (let [protocol-fn (util/var->symbol k)\n             interface-fn (symbol (.getName (:on-interface protocol))\n                                  (munge (name protocol-fn)))]\n         (concat ;; the interface method (no body, it's just a protocol)\n                 (build/node ast interface-fn)\n\n                 ;; the clojure function (no body, it's just a protocol)\n                 (build/node ast protocol-fn)\n\n                 ;; the `:method` op, which is used for method implementations\n                 ;; in deftype and defrecord, only knows about the interface\n                 ;; method, not the clojure protocol function. So it's simplest\n                 ;; to have all the calls go through the java interface, e.g.\n                 ;;\n                 ;;   deftype ------\\\n                 ;;                  inferface method\n                 ;;   protocol fn --/\n                 ;;\n                 (build/edge ast {:src protocol-fn, :dest interface-fn})))))))","label"="phone-tree.parse.ast/parse (quote clojure.core/defprotocol)"];
"phone-tree.redef/redef-form" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/redef.clj, line 22\n(defn redef-form\n  \"Redefines a form. Expects a def-style form with a fully-qualified symbol.\n\n  Ignores any redefs for namespaces that are not in the classpath.\"\n  [[head qualified-sym & body :as form]]\n  (let [sym-ns (symbol (namespace qualified-sym))\n        sym-name (symbol (name qualified-sym))\n        form-to-eval (cons head (cons sym-name body))]\n    ;; redefs should survive `require`, since we've already required the\n    ;; namespace here, but they definitely _won't_ survive :reload\n    (if (try-require sym-ns)\n      (binding [*ns* (find-ns sym-ns)]\n        (log/debugf \"Redefining %s\" qualified-sym)\n        (when (= 'defmulti head) (ns-unmap *ns* sym-name))\n        (eval form-to-eval))\n      (log/warnf \"Skipping redef %s: unable to require %s\" qualified-sym sym-ns))))","label"="phone-tree.redef/redef-form"];
"phone-tree.graph/sanitize-id" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 105\n(defn sanitize-id [id]\n  (str/replace id \":\" \"_\"))","label"="phone-tree.graph/sanitize-id"];
"loom.attr/add-attr" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.attr/add-attr"];
"ubergraph.core/viz-graph" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="ubergraph.core/viz-graph"];
"phone-tree.graph/collapse" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 84\n(defn collapse\n  \"Returns a graph that only contains `starting-nodes` (a coll or node\n  filtering function). Intermediate edges and nodes are collapsed.\"\n  [g starting-nodes-or-fn]\n  (let [starting-nodes (set (->starting-nodes g starting-nodes-or-fn))\n        edges (for [start starting-nodes\n                    end (->> (reachable-nodes (uber/successors g) #{start})\n                             (filter starting-nodes))\n                    ;; this would include self-edges by default (since\n                    ;; reachable-nodes also includes starting nodes), so don't\n                    ;; include the self-edge unless it actually exists\n                    :when (or (not= start end)\n                              (uber/find-edge g start end))]\n                [start end])\n        nodes (->> (reduce into starting-nodes edges)\n                   (map #(uber/node-with-attrs g %)))]\n    (apply uber/digraph (concat nodes edges))))","label"="phone-tree.graph/collapse"];
"phone-tree.core/collect-fn" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 23\n(defn collect-fn [m k v]\n  (update m k collect-val v))","label"="phone-tree.core/collect-fn"];
"phone-tree.parse.ast/first-form-var" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 24\n(defn first-form-var\n  \"Returns the first item of the original form, if it is a var used in a\n  function or macro call position.\"\n  [ast]\n  ;; If the original form was a macro, :raw-forms is a sequence of\n  ;; macroexpansions, so the first one is the original form. If the original\n  ;; form was not a macro, :form is the original form.\n  (let [raw-form (form ast)]\n    (when (list? raw-form)\n      (ast-resolve ast (first raw-form)))))","label"="phone-tree.parse.ast/first-form-var"];
"phone-tree.core/-main" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 171\n(defn -main [& args]\n  (run (parse-cli args)))","label"="phone-tree.core/-main"];
"phone-tree.parse.class/guess-class" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 79\n(defn guess-class\n  \"Returns the best guess return class for this ast node.\n\n  Ignores java.lang.Object\"\n  [ast]\n  ;; TODO: I think :class is not necessarily correct here: might need to be\n  ;; (guess-class (:class ast))?\n  #_(prn \"guess-class\"\n       (:form ast)\n       (select-keys (:env ast) [:file :line])\n       [(guess-class* ast)\n        (:class ast)\n        (:o-tag ast)\n        (:tag ast)])\n  (->> (keep #(% ast) [guess-class* :class :o-tag :tag])\n       (keep #(cond\n                (class? %) %\n                (map? %) (guess-class %)))\n       (remove #{java.lang.Object})\n       first))","label"="phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _method" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 87\n(defmethod ast/parse :method\n  [{:keys [this interface name body] :as ast}]\n  ;; - name is the method's name\n  ;; - interface is method's interface (usually attached to a protocol)\n  ;; - tag is the class (to dispatch on)\n  ;; - body is the method's body\n  (when-not (default-record-method? ast)\n    (let [fn-name (munge (str name))\n          interface-fn (symbol (.getName interface) fn-name)\n          class-fn (symbol (.getName (:tag this)) fn-name)]\n      (concat ;; the class method\n              (build/node ast class-fn body)\n              ;; a call from the interface-fn to the class method\n              ;; this is equivalent to multimethod dispatch (on class)\n              (build/edge ast {:src interface-fn, :dest class-fn})))))","label"="phone-tree.parse.ast/parse :method"];
"phone-tree.graph/tooltip" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 115\n(defn tooltip [{:keys [locations]}]\n  (->> (map (fn [{:keys [file line] :as location}]\n              (format \"%s, line %s\\n%s\" file line (form location))) locations)\n       (remove str/blank?)\n       (str/join \"\\n\\n\")\n       (not-empty)))","label"="phone-tree.graph/tooltip"];
"clojure.tools.namespace.track/tracker" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.namespace.track/tracker"];
"phone-tree.parse.build/node-type clojure.lang.Symbol" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 16\n(extend-protocol NodeType\n  clojure.lang.MultiFn\n  (node-type [_] :multimethod)\n  clojure.lang.Fn\n  (node-type [_] :function)\n  #_#_clojure.core.async.impl.protocols.Channel\n  (node-type [_] :channel)\n  java.lang.Class\n  (node-type [_] :class)\n  clojure.lang.Var\n  (node-type [v]\n    (cond\n      (:macro (meta v)) :macro\n      (:protocol (meta v)) :protocol-fn\n      :else (node-type (var-get v))))\n  clojure.lang.Symbol\n  (node-type [s]\n    (let [v (ns-resolve 'clojure.core s)]\n      (cond\n        v (node-type v)\n        (find-ns s) :namespace\n        (and (namespace s) (class? (ns-resolve 'clojure.core (symbol (namespace s))))) :method\n        :else nil)))\n  ;; Defaults\n  java.lang.Object\n  (node-type [_] nil)\n  nil\n  (node-type [_] nil))","label"="phone-tree.parse.build/node-type clojure.lang.Symbol"];
"phone-tree.graph/form" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 110\n(defn form [{:keys [file line end-line]}]\n  (let [block (subvec (read-lines file) (dec line) end-line)]\n    ;; TODO: do we care about column and end-column?\n    (str/join \"\\n\" block)))","label"="phone-tree.graph/form"];
"clojure.tools.cli/parse-opts" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.cli/parse-opts"];
"ubergraph.core/node-with-attrs" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="ubergraph.core/node-with-attrs"];
"loom.graph/digraph" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/digraph"];
"phone-tree.graph/digraph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 24\n(defn digraph\n  \"loom.graph/digraph wrapper that allows nodes and edges to have attrs\"\n  [& nodes-and-edges]\n  (reduce (fn [g init]\n            (cond\n              (not (sequential? init)) (lg/add-nodes g init)\n              (map? (second init)) (-> g\n                                       (lg/add-nodes (first init))\n                                       (merge-attrs (first init) (second init)))\n              :else (-> g\n                        (lg/add-edges (take 2 init))\n                        (merge-attrs (vec (take 2 init)) (nth init 2 nil)))))\n          (lg/digraph)\n          nodes-and-edges))","label"="phone-tree.graph/digraph"];
"phone-tree.graph/filter-ancestors" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 77\n(defn filter-ancestors\n  \"Returns a graph with nodes and edges that are ancestors of `starting-nodes`\n  (a coll or node filtering function).\"\n  [g starting-nodes-or-fn]\n  (let [starting-nodes (->starting-nodes g starting-nodes-or-fn)]\n    (filter-nodes g (reachable-nodes (uber/predecessors g) starting-nodes))))","label"="phone-tree.graph/filter-ancestors"];
"dorothy.core/safe-id?" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="dorothy.core/safe-id?"];
"phone-tree.graph/merge-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 13\n(defn merge-attrs [g node-or-edge attrs]\n  (reduce-kv (fn [g k v] (la/add-attr g node-or-edge k v))\n             g\n             attrs))","label"="phone-tree.graph/merge-attrs"];
"phone-tree.html/mini-hbs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/html.clj, line 9\n(defn mini-hbs\n  \"Mini hbs renderer\"\n  [template context]\n  (-> template\n      (str/replace #\"\\{\\{>\\s*(\\S+)\\s*\\}\\}\" (fn [[_ file]]\n                                             (read-html-resource file)))\n      (str/replace #\"\\{\\{\\s*(\\S+)\\s*\\}\\}\" (fn [[_ k]]\n                                            (get context (keyword k))))))","label"="phone-tree.html/mini-hbs"];
"phone-tree.graph/filter-descendants" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 70\n(defn filter-descendants\n  \"Returns a graph with nodes and edges that are descendants of `starting-nodes`\n  (a coll or node filtering function).\"\n  [g starting-nodes-or-fn]\n  (let [starting-nodes (->starting-nodes g starting-nodes-or-fn)]\n    (filter-nodes g (reachable-nodes (uber/successors g) starting-nodes))))","label"="phone-tree.graph/filter-descendants"];
"loom.graph/remove-nodes" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/remove-nodes"];
"phone-tree.graph/->csv" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 205\n(defn ->csv\n  \"Returns csv output\"\n  [g]\n  (let [topology (->topology g)\n        lines (map flatten topology)\n        writer (java.io.StringWriter.)]\n    (csv/write-csv writer lines)\n    (str writer)))","label"="phone-tree.graph/->csv"];
"phone-tree.parse.namespace" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/namespace.clj, line 1\n(ns phone-tree.parse.namespace\n  \"Clojure namespace parsing.\"\n  (:require [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]))","label"="phone-tree.parse.namespace"];
"phone-tree.parse.build/node-type clojure.lang.MultiFn" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 16\n(extend-protocol NodeType\n  clojure.lang.MultiFn\n  (node-type [_] :multimethod)\n  clojure.lang.Fn\n  (node-type [_] :function)\n  #_#_clojure.core.async.impl.protocols.Channel\n  (node-type [_] :channel)\n  java.lang.Class\n  (node-type [_] :class)\n  clojure.lang.Var\n  (node-type [v]\n    (cond\n      (:macro (meta v)) :macro\n      (:protocol (meta v)) :protocol-fn\n      :else (node-type (var-get v))))\n  clojure.lang.Symbol\n  (node-type [s]\n    (let [v (ns-resolve 'clojure.core s)]\n      (cond\n        v (node-type v)\n        (find-ns s) :namespace\n        (and (namespace s) (class? (ns-resolve 'clojure.core (symbol (namespace s))))) :method\n        :else nil)))\n  ;; Defaults\n  java.lang.Object\n  (node-type [_] nil)\n  nil\n  (node-type [_] nil))","label"="phone-tree.parse.build/node-type clojure.lang.MultiFn"];
"phone-tree.log/warnf" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 34\n(def warnf (partial logf :warn))","label"="phone-tree.log/warnf"];
"phone-tree.parse.build/node-type" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 13\n(defprotocol NodeType\n  (node-type [this]))","label"="phone-tree.parse.build/node-type"];
"phone-tree.core/prune-graph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 136\n(defn prune-graph [g opts]\n  (if-let [collapse (:collapse opts)]\n    ;; collapse is a special case\n    (graph/collapse g (partial matches-any? collapse))\n    ;; otherwise prune\n    (let [{:keys [include-node exclude-node]} opts\n          {:keys [include-ancestors include-descendants]} opts]\n      (cond-> g\n        (seq include-node) (graph/filter-nodes (partial matches-any? include-node))\n        (seq exclude-node) (graph/remove-nodes (partial matches-any? exclude-node))\n        (seq include-ancestors) (graph/filter-ancestors (partial matches-any? include-ancestors))\n        (seq include-descendants) (graph/filter-descendants (partial matches-any? include-descendants))))))","label"="phone-tree.core/prune-graph"];
"phone-tree.parse.class/guess-class* _default" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 61\n(defmethod guess-class* :default\n  [_]\n  nil)","label"="phone-tree.parse.class/guess-class* :default"];
"phone-tree.core/matches-any?" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 126\n(defn matches-any? [regexes s]\n  (seq (filter #(re-matches % s) regexes)))","label"="phone-tree.core/matches-any?"];
"clojure.java.io/resource" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.java.io/resource"];
"phone-tree.core/run-with-project" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 168\n(defn run-with-project [project-opts & args]\n  (run (merge project-opts (parse-cli args))))","label"="phone-tree.core/run-with-project"];
"phone-tree.redef/read-forms" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/redef.clj, line 6\n(defn read-forms\n  \"Reads all forms in a file.\"\n  [filename]\n  (with-open [r (io/reader filename)]\n    (let [pbr (java.io.PushbackReader. r)]\n      (doall\n        (take-while #(not= ::EOF %)\n                    (repeatedly #(read {:eof ::EOF} pbr)))))))","label"="phone-tree.redef/read-forms"];
"phone-tree.namespace/nss-in-dirs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/namespace.clj, line 18\n(defn nss-in-dirs\n  \"Return a map containing a list of all the project's namespaces.\"\n  [dirs]\n  (let [tracker (if (seq dirs)\n                  (apply dir/scan-all (track/tracker) dirs)\n                  (track/tracker))]\n    (::track/load tracker)))","label"="phone-tree.namespace/nss-in-dirs"];
"phone-tree.parse.build/edge" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 70\n(defn edge\n  \"Builds a graph edge, returning a sequence with a single edge.\"\n  [ast {:keys [src dest]}]\n  (if src\n    (list (->edge {:src (node-id src)\n                   :dest (node-id dest)\n                   :location (ast/location ast)}))\n    ;; make an edge from the current *parent* (or the namespace if it's a\n    ;; top-level form)\n    (when-let [parent (or *parent* (get-in ast [:env :ns]))]\n      (log/tracef \"Adding edge from *parent* %s (%s) to %s\" *parent* parent dest)\n      (recur ast {:src parent, :dest dest}))))","label"="phone-tree.parse.build/edge"];
"phone-tree.log/*level*" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 4\n(def ^:dynamic *level* :warn)","label"="phone-tree.log/*level*"];
"clojure.tools.analyzer.jvm/analyze" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.analyzer.jvm/analyze"];
"phone-tree.parse.ast/parse _quote" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/macro.clj, line 25\n(defmethod ast/parse :quote\n  [{:keys [expr] :as ast}]\n  (if (and *in-macro* (= :symbol (:type expr)))\n    (build/edge ast {:dest (:val expr)})\n    (ast/parse-children expr)))","label"="phone-tree.parse.ast/parse :quote"];
"phone-tree.parse.build/*parent*" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 10\n(def ^:dynamic *parent* nil)","label"="phone-tree.parse.build/*parent*"];
"phone-tree.parse.ast/parse _var" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/var.clj, line 17\n(defmethod ast/parse :var\n  [{:keys [var] :as ast}]\n  (build/edge ast {:dest var}))","label"="phone-tree.parse.ast/parse :var"];
"phone-tree.parse.build/node-type java.lang.Object" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 16\n(extend-protocol NodeType\n  clojure.lang.MultiFn\n  (node-type [_] :multimethod)\n  clojure.lang.Fn\n  (node-type [_] :function)\n  #_#_clojure.core.async.impl.protocols.Channel\n  (node-type [_] :channel)\n  java.lang.Class\n  (node-type [_] :class)\n  clojure.lang.Var\n  (node-type [v]\n    (cond\n      (:macro (meta v)) :macro\n      (:protocol (meta v)) :protocol-fn\n      :else (node-type (var-get v))))\n  clojure.lang.Symbol\n  (node-type [s]\n    (let [v (ns-resolve 'clojure.core s)]\n      (cond\n        v (node-type v)\n        (find-ns s) :namespace\n        (and (namespace s) (class? (ns-resolve 'clojure.core (symbol (namespace s))))) :method\n        :else nil)))\n  ;; Defaults\n  java.lang.Object\n  (node-type [_] nil)\n  nil\n  (node-type [_] nil))","label"="phone-tree.parse.build/node-type java.lang.Object"];
"phone-tree.parse.ast/parse-dispatch" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 63\n(defn parse-dispatch [ast]\n  ;; In order to return only the most specific of the possibilities returned by\n  ;; `dispatches`, we need to examine the actual defined methods\n  (->> (dispatches ast)\n       (filter (partial contains? (methods parse)))\n       (first)))","label"="phone-tree.parse.ast/parse-dispatch"];
"loom.graph/successors" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/successors"];
"phone-tree.parse.protocol/protocol-dispatch" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 41\n(defn protocol-dispatch\n  \"Finds the class that implements the given protocol.\"\n  [protocol cls]\n  (if (isa? cls (:on-interface protocol))\n    ;; If this is from a deftype or defrecord, the class _is_ the implementer\n    cls\n    ;; Otherwise search through superclasses\n    (and cls (->> (super-chain (box cls))\n                  (filter (partial get (:impls protocol)))\n                  first))))","label"="phone-tree.parse.protocol/protocol-dispatch"];
"phone-tree.parse.build/->node" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 64\n(defn ->node [attrs]\n  (assoc attrs :id (node-id attrs)))","label"="phone-tree.parse.build/->node"];
"phone-tree.parse.class/guess-class*" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 59\n(defmulti guess-class* :op)","label"="phone-tree.parse.class/guess-class*"];
"loom.attr/attr" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.attr/attr"];
"clojure.tools.analyzer.ast/children" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.analyzer.ast/children"];
"phone-tree.parse.build/attrs->ubergraph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 115\n(defn attrs->ubergraph [attrs]\n  (if (and (:src attrs) (:dest attrs))\n    ;; edge\n    [(:src attrs) (:dest attrs) (dissoc attrs :src :dest)]\n    ;; node\n    [(:id attrs) (dissoc attrs :id)]))","label"="phone-tree.parse.build/attrs->ubergraph"];
"clojure.string/split-lines" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.string/split-lines"];
"loom.graph/src" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/src"];
"phone-tree.html/read-html-resource" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/html.clj, line 6\n(defn read-html-resource [filename]\n  (slurp (io/resource (str \"html/\" filename))))","label"="phone-tree.html/read-html-resource"];
"phone_tree.parse.build.NodeType/node_type" ["fillcolor"="lightcyan","style"="filled","class"="node method","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 13\n(defprotocol NodeType\n  (node-type [this]))","label"="phone_tree.parse.build.NodeType/node_type"];
"phone-tree.parse.ast/parse _protocol-invoke" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 181\n(defmethod ast/parse :protocol-invoke\n  [{:keys [protocol-fn target args] :as ast}]\n  (let [protocol (-> protocol-fn :meta :protocol var-get)\n        protocol-fn (util/var->symbol (:var protocol-fn))\n        interface (:on-interface protocol)\n        target (guess-class target)\n        to (if (isa? target interface)\n             ;; class is an implementer -- use a class method\n             {:symbol (symbol (.getName target) (munge (name protocol-fn)))}\n             ;; class is not an implementer -- use the protocol function\n             ;; itself; if we have a class, attempt to find a dispatch value\n             (let [dispatch (protocol-dispatch protocol target)]\n               (cond-> {:symbol protocol-fn}\n                 dispatch (assoc :dispatch dispatch))))]\n    (concat ;; edge to the protocol fn itself\n            (build/edge ast {:dest to})\n            ;; any args should be parsed as if they were children of the\n            ;; enclosing scope\n            (mapcat ast/parse (cons target args)))))","label"="phone-tree.parse.ast/parse :protocol-invoke"];
"clojure.string/blank?" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.string/blank?"];
"phone-tree.parse.class/record-reify!" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 35\n(defn record-reify!\n  \"Records this reify form in `reify-templates`\n\n  Called during analysis of reify forms.\"\n  [cls metadata]\n  (let [prefix (reify-prefix cls)]\n    (when (and prefix metadata)\n      (swap! reify-templates assoc [prefix metadata] cls))))","label"="phone-tree.parse.class/record-reify!"];
"phone-tree.parse.class/guess-class* _const" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 71\n(defmethod guess-class* :const\n  [ast]\n  (if (= :class (:type ast))\n    (:val ast) ;; TODO: there might be exceptions to this, e.g. record or type?\n    (do\n      (log/debugf \"guess-class with :const %s node: %s\" (:type ast) ast)\n      (class (:val ast)))))","label"="phone-tree.parse.class/guess-class* :const"];
"phone-tree.parse.protocol/super-chain" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 37\n(defn super-chain [^Class c]\n  (when c\n    (cons c (super-chain (.getSuperclass c)))))","label"="phone-tree.parse.protocol/super-chain"];
"phone-tree.parse.protocol/default-record-methods" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 15\n(def default-record-methods\n  (delay\n   (->> '(defrecord Test [])\n        ana.jvm/analyze\n        ana.ast/nodes\n        (filter (comp #{:method} :op))\n        (map (juxt :interface :name))\n        set)))","label"="phone-tree.parse.protocol/default-record-methods"];
"phone-tree.log/warn" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 23\n(def warn (partial log :warn))","label"="phone-tree.log/warn"];
"phone-tree.core/exclude-java-regex" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 28\n(def exclude-java-regex #\"java\\.(lang\\.|util\\.).*\")","label"="phone-tree.core/exclude-java-regex"];
"phone-tree.parse.protocol" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 1\n(ns phone-tree.parse.protocol\n  \"Protocol, record, type, and reify parsing\"\n  (:require [clojure.tools.analyzer.jvm.utils :refer [box]]\n            [clojure.tools.analyzer.jvm :as ana.jvm]\n            [clojure.tools.analyzer.ast :as ana.ast]\n            [phone-tree.log :as log]\n            [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]\n            [phone-tree.parse.class :refer [guess-class]]\n            [phone-tree.util :as util]))","label"="phone-tree.parse.protocol"];
"clojure.string/split" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.string/split"];
"ubergraph.core/escape-label" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="ubergraph.core/escape-label"];
"phone-tree.graph/edge-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 122\n(defn edge-attrs [e attrs]\n  {:class \"edge\"\n   :tooltip (format \"%s -> %s\" (uber/src e) (uber/dest e))}\n  #_(let [tt (tooltip attrs)]\n    (cond-> {:class \"edge\"}\n      tt (assoc :tooltip (str/replace (uber/escape-label tt) \"\\n\" \"\\\\n\")))))","label"="phone-tree.graph/edge-attrs"];
"phone-tree.parse.ast" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 1\n(ns phone-tree.parse.ast\n  \"AST parsing functions\"\n  (:require [clojure.tools.analyzer.ast :as ana.ast]\n            [phone-tree.util :as util]))","label"="phone-tree.parse.ast"];
"phone-tree.parse.ast/parse _the-var" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/var.clj, line 23\n(defmethod ast/parse :the-var\n  [ast]\n  (build/edge ast {:dest (:var ast)}))","label"="phone-tree.parse.ast/parse :the-var"];
"phone-tree.parse.ast/location" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 6\n(defn location\n  \"Selects the location metadata from an ast node.\"\n  [ast]\n  (select-keys (:env ast) [:file :ns :line :end-line :column :end-column]))","label"="phone-tree.parse.ast/location"];
"phone-tree.redef/load-redefs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/redef.clj, line 39\n(defn load-redefs\n  [filename]\n  (log/debugf \"Loading redefs from %s\" filename)\n  (->> (read-forms filename)\n       (map redef-form)\n       (filter identity)\n       set))","label"="phone-tree.redef/load-redefs"];
"java.io.Reader/close" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="java.io.Reader/close"];
"java.io.StringWriter/." ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="java.io.StringWriter/."];
"loom.alg-generic/bf-traverse" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.alg-generic/bf-traverse"];
"phone-tree.parse.class/guess-class* _var" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 65\n(defmethod guess-class* :var\n  [ast]\n  (let [v (var-get (:var ast))]\n    (or (reify-class v)\n        (class v))))","label"="phone-tree.parse.class/guess-class* :var"];
"phone-tree.graph/->topology" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 196\n(defn ->topology\n  \"Transforms a graph into a lein-topology compatible format:\n  a map of {[src dest] call-count}\"\n  [g]\n  (->> (uber/edges g)\n       (map (fn [e]\n              [[(uber/src e) (uber/dest e)] (or (uber/attr g e :count) 1)]))\n       (into {})))","label"="phone-tree.graph/->topology"];
"phone-tree.parse.ast/parse (quote clojure.core/in-ns)" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/namespace.clj, line 6\n(defmethod ast/parse 'clojure.core/in-ns\n  [{:keys [result args] :as ast}]\n  (build/node ast {:symbol (ns-name result) :type :namespace} args))","label"="phone-tree.parse.ast/parse (quote clojure.core/in-ns)"];
"phone-tree.parse.class" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 1\n(ns phone-tree.parse.class\n  \"Class guessing.\"\n  (:require [phone-tree.log :as log]\n            [phone-tree.parse.ast :as ast]))","label"="phone-tree.parse.class"];
"phone-tree.namespace" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/namespace.clj, line 1\n(ns phone-tree.namespace\n  \"Namespace utilities\"\n  (:require [clojure.tools.namespace.dir :as dir]\n            [clojure.tools.namespace.track :as track]))","label"="phone-tree.namespace"];
"phone-tree.util/var->symbol" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/util.clj, line 3\n(defn var->symbol [v]\n  (symbol (some-> v meta :ns str)\n          (some-> v meta :name str)))","label"="phone-tree.util/var->symbol"];
"phone-tree.core/cli-options" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 31\n(def cli-options\n  [;; Output options\n   [\"-T\" \"--format TYPE\"\n    \"Output format (edn, dot, html, csv)\"\n    :default :edn\n    :parse-fn keyword\n    ;; TODO: I can't tell if this is a difference in versions or what, but\n    ;; sometimes this wants to be a vector and sometimes it wants to be a\n    ;; function :shrug:\n    #_#_:validate-fn [#{:edn :dot :html :csv}]]\n   [nil \"--dot-attr KEY=VALUE\"\n    \"Global dot output options (can be repeated).\"\n    :default ^::replace {:rankdir \"LR\"}\n    :parse-fn (fn [s]\n                (->> (str/split s #\"\\s*;\\s*\")\n                     (map #(str/split % #\"\\s*=\\s*\" 2))\n                     (into {})))\n    :assoc-fn collect-fn]\n\n   ;; Graph building options\n   [\"-n\" \"--include-ns REGEX\"\n    \"Project namespaces to analyze (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n   [\"-e\" \"--exclude-ns REGEX\"\n    \"Project namespaces to exclude from analysis (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n\n   ;; Graph pruning options\n   ;; TODO: might remove --include-clojure and --include-java for now?\n   [nil \"--include-clojure\"\n    \"Include clojure.core and clojure.lang nodes in the graph.\"\n    :default false]\n   [nil \"--include-java\"\n    \"Include java.lang and java.util nodes in the graph.\"\n    :default false]\n   [nil \"--exclude-node REGEX\"\n    \"Exclude these nodes from the graph (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n   [nil \"--include-node REGEX\"\n    \"Include only these nodes in the graph (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n   [\"-S\" \"--include-descendants REGEX\"\n    \"Include only descendants of these nodes in the graph (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n   [\"-P\" \"--include-ancestors REGEX\"\n    \"Include only ancestors of these nodes in the graph (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n   [nil \"--collapse REGEX\"\n    \"Collapse intermediate edges between these nodes (can be repeated).\"\n    :parse-fn re-pattern\n    :assoc-fn collect-fn]\n\n   ;; Misc options\n   [\"-v\" nil\n    \"Set verbosity (repeat to increase verbosity)\"\n    :id :log-level\n    :assoc-fn (fn [m k _]\n                (update m k #(case %\n                               (nil, :warn) :debug\n                               :debug :trace\n                               :trace)))]\n   ])","label"="phone-tree.core/cli-options"];
"loom.graph/edges" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/edges"];
"phone-tree.parse.ast/parse _def" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/var.clj, line 10\n(defmethod ast/parse :def\n  [{:keys [var init] :as ast}]\n  ;; - symbol is the node's :var\n  ;; - body is the node's :init\n  (build/node ast var init))","label"="phone-tree.parse.ast/parse :def"];
"phone-tree.parse.ast/parse _new" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/interop.clj, line 55\n(defmethod ast/parse :new\n  [{:keys [class args] :as ast}]\n  (let [cls (or (guess-class class)\n                (guess-class ast))]\n    (concat ;; edge to the constructor\n            (build/edge ast {:dest (symbol (.getName cls) \".\")})\n            ;; args are parsed as children of the enclosing scope\n            (ast/parse-children args))))","label"="phone-tree.parse.ast/parse :new"];
"loom.graph/add-nodes" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/add-nodes"];
"phone-tree.core" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 1\n(ns phone-tree.core\n  (:require [clojure.string :as str]\n            [clojure.tools.cli :as cli]\n            [phone-tree.graph :as graph]\n            [phone-tree.log :as log]\n            [phone-tree.html :as html]\n            [phone-tree.namespace :refer [nss-in-dirs prepare-namespaces]]\n            [phone-tree.parse :as parse]\n            [ubergraph.core :as uber]\n\n            #_[clj-async-profiler.core :as prof]\n            ))","label"="phone-tree.core"];
"loom.graph/predecessors" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/predecessors"];
"phone-tree.parse/parse-ns" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse.clj, line 40\n(defn parse-ns [sym]\n  (log/debugf \"Parsing namespace: %s\" sym)\n  (mapcat ast/parse (ana.jvm/analyze-ns sym)))","label"="phone-tree.parse/parse-ns"];
"phone-tree.log/log" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 15\n(defn log\n  [level & strs]\n  (when (enabled? level)\n    (binding [*out* *err*]\n      (apply println strs))))","label"="phone-tree.log/log"];
"phone-tree.parse.build/node-type java.lang.Class" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 16\n(extend-protocol NodeType\n  clojure.lang.MultiFn\n  (node-type [_] :multimethod)\n  clojure.lang.Fn\n  (node-type [_] :function)\n  #_#_clojure.core.async.impl.protocols.Channel\n  (node-type [_] :channel)\n  java.lang.Class\n  (node-type [_] :class)\n  clojure.lang.Var\n  (node-type [v]\n    (cond\n      (:macro (meta v)) :macro\n      (:protocol (meta v)) :protocol-fn\n      :else (node-type (var-get v))))\n  clojure.lang.Symbol\n  (node-type [s]\n    (let [v (ns-resolve 'clojure.core s)]\n      (cond\n        v (node-type v)\n        (find-ns s) :namespace\n        (and (namespace s) (class? (ns-resolve 'clojure.core (symbol (namespace s))))) :method\n        :else nil)))\n  ;; Defaults\n  java.lang.Object\n  (node-type [_] nil)\n  nil\n  (node-type [_] nil))","label"="phone-tree.parse.build/node-type java.lang.Class"];
"phone-tree.graph/reachable-nodes" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 56\n(defn reachable-nodes\n  \"Returns the set of nodes that are reachable from `starting-nodes`.\"\n  [neighbors-fn starting-nodes]\n  (letfn [(neighbors [node]\n            (if (= ::start node)\n              starting-nodes\n              (neighbors-fn node)))]\n    (set (loom.alg/bf-traverse neighbors ::start))))","label"="phone-tree.graph/reachable-nodes"];
"phone-tree.graph" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 1\n(ns phone-tree.graph\n  \"Graph manipulation functions\"\n  (:require [clojure.data.csv :as csv]\n            [clojure.data.json :as json]\n            [clojure.string :as str]\n            [loom.alg-generic :as loom.alg]\n            [loom.graph :as lg]\n            [loom.attr :as la]\n            [ubergraph.core :as uber]))","label"="phone-tree.graph"];
"phone-tree.parse/ns->graph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse.clj, line 44\n(defn ns->graph\n  \"Returns a call graph for a namespace symbol.\"\n  [sym]\n  (build/ubergraph (parse-ns sym)))","label"="phone-tree.parse/ns->graph"];
"phone-tree.core/collect-val" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 16\n(defn collect-val [existing v]\n  (if (::replace (meta existing))\n    (recur (vary-meta (empty existing) dissoc ::replace) v)\n    (if (map? v)\n      (merge existing v)\n      (conj (or existing []) v))))","label"="phone-tree.core/collect-val"];
"phone-tree.parse.build" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 1\n(ns phone-tree.parse.build\n  \"Call graph building functions.\"\n  (:require [phone-tree.parse.ast :as ast]\n            [phone-tree.log :as log]\n            [phone-tree.util :as util]\n            [ubergraph.core :as uber]))","label"="phone-tree.parse.build"];
"phone-tree.parse.macro" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/macro.clj, line 1\n(ns phone-tree.parse.macro\n  \"defmacro and syntax quote parsing.\"\n  (:require [clojure.tools.analyzer.ast :as ana.ast]\n            [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]))","label"="phone-tree.parse.macro"];
"phone-tree.html" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/html.clj, line 1\n(ns phone-tree.html\n  \"HTML render using vis.js\"\n  (:require [clojure.java.io :as io]\n            [clojure.string :as str]))","label"="phone-tree.html"];
"ubergraph.protocols/find-edge" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="ubergraph.protocols/find-edge"];
"phone-tree.parse.ast/form" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 11\n(defn form\n  \"Returns the original form for this ast.\"\n  [ast]\n  (or (first (:raw-forms ast))\n      (:form ast)))","label"="phone-tree.parse.ast/form"];
"ubergraph.core/digraph" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="ubergraph.core/digraph"];
"phone-tree.redef" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/redef.clj, line 1\n(ns phone-tree.redef\n  \"Functions that provide macro redefs.\"\n  (:require [clojure.java.io :as io]\n            [phone-tree.log :as log]))","label"="phone-tree.redef"];
"phone-tree.parse.protocol/default-record-method?" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 27\n(defn default-record-method?\n  \"Does this ast represent a default `defrecord` method?\"\n  [{:keys [this interface name] :as ast}]\n  (and (record-class? (:tag this))\n       (contains? @default-record-methods [interface name])))","label"="phone-tree.parse.protocol/default-record-method?"];
"phone-tree.core/run" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 156\n(defn run [opts]\n  (binding [log/*level* (:log-level opts :warn)]\n    (log/debugf \"parsed command line %s\" opts)\n    (when-let [exit-code (:exit opts)]\n      (some-> opts :message println)\n      (System/exit exit-code))\n    (-> (find-namespaces opts)\n        (prepare-namespaces)\n        (parse/nss->graph)\n        (prune-graph opts)\n        (print-graph opts))))","label"="phone-tree.core/run"];
"phone-tree.parse.build/node-type clojure.lang.Var" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 16\n(extend-protocol NodeType\n  clojure.lang.MultiFn\n  (node-type [_] :multimethod)\n  clojure.lang.Fn\n  (node-type [_] :function)\n  #_#_clojure.core.async.impl.protocols.Channel\n  (node-type [_] :channel)\n  java.lang.Class\n  (node-type [_] :class)\n  clojure.lang.Var\n  (node-type [v]\n    (cond\n      (:macro (meta v)) :macro\n      (:protocol (meta v)) :protocol-fn\n      :else (node-type (var-get v))))\n  clojure.lang.Symbol\n  (node-type [s]\n    (let [v (ns-resolve 'clojure.core s)]\n      (cond\n        v (node-type v)\n        (find-ns s) :namespace\n        (and (namespace s) (class? (ns-resolve 'clojure.core (symbol (namespace s))))) :method\n        :else nil)))\n  ;; Defaults\n  java.lang.Object\n  (node-type [_] nil)\n  nil\n  (node-type [_] nil))","label"="phone-tree.parse.build/node-type clojure.lang.Var"];
"phone-tree.graph/filter-nodes" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 49\n(defn filter-nodes\n  \"Filters nodes and edges given a function `f` that takes a node id.\n\n  Edges will be included if both :src and :dest match.\"\n  [g f]\n  (remove-nodes g (complement f)))","label"="phone-tree.graph/filter-nodes"];
"phone-tree.parse.ast/parse" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 61\n(declare parse)\n\nfile:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 70\n(defmulti parse\n  \"Parses an `ast` into an intermediate graph representation (a combined seq of\n  nodes and edges).\n\n  Dispatches on the most specific of:\n\n  - java method (as a symbol)\n  - clojure function or macro (fully qualified symbol)\n  - ast node :op (keyword)\"\n  parse-dispatch)","label"="phone-tree.parse.ast/parse"];
"phone-tree.log/trace" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 21\n(def trace (partial log :trace))","label"="phone-tree.log/trace"];
"phone-tree.graph/->json" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 179\n(defn ->json\n  \"Returns a json representation of a graph.\n\n  Notes have :id and :attrs (dot attrs)\n  Edges have :src :dest and :attrs (dot attrs)\"\n  [g]\n  (let [g (with-dot-attrs g)]\n    (json/write-str {:nodes (for [n (uber/nodes g)]\n                              {:id n\n                               :attrs (uber/attrs g n)})\n                     :edges (for [e (uber/edges g)]\n                              {:src (uber/src e)\n                               :dest (uber/dest e)\n                               :attrs (uber/attrs g e)})})))","label"="phone-tree.graph/->json"];
"clojure.tools.analyzer.ast/nodes" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.analyzer.ast/nodes"];
"phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod)" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/multimethod.clj, line 11\n(defmethod ast/parse 'clojure.lang.MultiFn/addMethod\n  [{:keys [instance args] :as ast}]\n  ;; - symbol is the multifn (an object that we're calling .addMethod on)\n  ;; - dispatch is the first argument to .addMethod\n  ;; - body is the second argument to .addMethod\n  (let [[dispatch body] args\n        multimethod-node {:symbol (:var instance) :dispatch (:form dispatch)}]\n    (concat ;; the multimethod itself\n            (build/node ast multimethod-node body)\n            ;; edge from the main method\n            (build/edge ast {:src (dissoc multimethod-node :dispatch)\n                             :dest multimethod-node}))))","label"="phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod)"];
"phone-tree.graph/with-dot-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 148\n(defn with-dot-attrs\n  \"Returns an ubergraph with attrs suitable for dot output.\"\n  [g]\n  (let [nodes (for [n (uber/nodes g)]\n                [(sanitize-id n)\n                 (assoc (node-attrs n (uber/attrs g n)) :label n)])\n        edges (for [e (uber/edges g)]\n                [(sanitize-id (uber/src e))\n                 (sanitize-id (uber/dest e))\n                 (edge-attrs e (uber/attrs g e))])]\n    (apply uber/digraph (concat nodes edges))))","label"="phone-tree.graph/with-dot-attrs"];
"phone-tree.parse.build/conform-node" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 46\n(defn conform-node [x]\n  (cond\n    (not (map? x)) (recur {:symbol x})\n    (var? (:symbol x)) (-> x\n                           (update :symbol util/var->symbol)\n                           (assoc :type (node-type (:symbol x))))\n    (symbol? (:symbol x)) (assoc x :type (node-type (:symbol x)))\n    (not (symbol? (:symbol x))) (throw (ex-info \"Node must be a symbol or var\" x))\n    :else x))","label"="phone-tree.parse.build/conform-node"];
"phone-tree.log/tracef" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 32\n(def tracef (partial logf :trace))","label"="phone-tree.log/tracef"];
"phone-tree.parse.protocol/record-class?" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 24\n(defn record-class? [cls]\n  (.isAssignableFrom clojure.lang.IRecord cls))","label"="phone-tree.parse.protocol/record-class?"];
"phone-tree.parse.ast/parse (quote clojure.core/defmacro)" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/macro.clj, line 15\n(defmethod ast/parse 'clojure.core/defmacro\n  [ast]\n  (binding [*in-macro* true]\n    (->> (ana.ast/nodes ast)\n         (filter (comp #{:def} :op))\n         (first)\n         (ast/parse)\n         (doall))))","label"="phone-tree.parse.ast/parse (quote clojure.core/defmacro)"];
"phone-tree.parse.class/reify-class" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 44\n(defn reify-class\n  \"Returns the (synthetic) class for a var with a reified class.\"\n  [v]\n  (let [prefix (some->> v class reify-prefix)\n        metadata (meta v)]\n    (get @reify-templates [prefix metadata])))","label"="phone-tree.parse.class/reify-class"];
"phone-tree.parse" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse.clj, line 1\n(ns phone-tree.parse\n  \"Functions for generating call graphs from namespaces.\n\n  A call graph is represented as an `ubergraph` digraph.\n\n  Each defined var, class, protocol, etc. is a node in the graph. Each\n  reference from one var to another (e.g. a function call, but any use is\n  counted) is an edge in the graph.\n\n  Node ids are formed by concatenating the symbol with the dispatch value (if\n  any). Nodes have the following attributes:\n\n    :symbol    -- the var that was defined (as a fully-qualified symbol)\n    :dispatch  -- the dispatch value (for multimethods and types/records)\n    :count     -- number of times this var was defined\n    :locations -- a set of location metadata (:ns, :file, :line, etc.)\n    :forms     -- a set of the original forms that defined this var\n    :external? -- true for nodes that were not defined in an analyzed namespace\n\n  Edges have the following attributes:\n\n    :count     -- number of times the edge's src called the edge's dest\n    :locations -- a set of location metadata (:ns, :file, :line, etc.)\n\n  Note: vars can be defined multiple times, and one function may call another\n  multiple times. For the sake of simplicity, these cases are still represented\n  as single nodes and edges in the graph, and the `:count` and `:locations`\n  attributes can be used to identify each def or call.\"\n  (:require [clojure.tools.analyzer.jvm :as ana.jvm]\n            [phone-tree.log :as log]\n            [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]\n            ;; parsing implementations\n            [phone-tree.parse.interop]\n            [phone-tree.parse.multimethod]\n            #_[phone-tree.parse.namespace]\n            [phone-tree.parse.protocol]\n            [phone-tree.parse.var]))","label"="phone-tree.parse"];
"loom.graph/dest" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.graph/dest"];
"phone-tree.core/find-namespaces" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/core.clj, line 129\n(defn find-namespaces [{:keys [source-paths include-ns exclude-ns]}]\n  (cond->> (nss-in-dirs source-paths)\n    true (map str)\n    (seq include-ns) (filter (partial matches-any? include-ns))\n    (seq exclude-ns) (remove (partial matches-any? exclude-ns))\n    true (map symbol)))","label"="phone-tree.core/find-namespaces"];
"phone-tree.graph/node-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 129\n(defn node-attrs [_ {:keys [external? type] :as attrs}]\n  (let [tt (tooltip attrs)]\n    (cond-> {:class \"node\"\n             :style \"filled\"\n             :fillcolor \"white\"}\n      external? (update :style str \",dashed\")\n      tt (assoc :tooltip (str/replace (uber/escape-label tt) \"\\n\" \"\\\\n\"))\n      ;; playing around\n      type (update :class str \" \" (name type))\n      (= :multimethod type) (assoc :fillcolor \"lavender\")\n      (= :protocol-fn type) (assoc :fillcolor \"lavender\")\n      (= :channel type) (assoc :fillcolor \"black\")\n      (= :function type) (assoc :fillcolor \"white\")\n      (= :namespace type) (assoc :fillcolor \"lightpink\")\n      (= :macro type) (assoc :fillcolor \"palegreen\")\n      (= :class type) (assoc :fillcolor \"lightcyan\")\n      (= :method type) (assoc :fillcolor \"lightcyan\")\n      (not type) (assoc :fillcolor \"gray\"))))","label"="phone-tree.graph/node-attrs"];
"phone-tree.parse.multimethod" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/multimethod.clj, line 1\n(ns phone-tree.parse.multimethod\n  \"Multimethod parsing\"\n  (:require [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]))","label"="phone-tree.parse.multimethod"];
"phone-tree.parse.build/node" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 83\n(defn node\n  \"Builds a graph node, returning a sequence of it and the result of parsing\n  any `body-asts`.\"\n  [ast node & body-asts]\n  (let [node (-> (conform-node node)\n                 (assoc :location (ast/location ast))\n                 (->node))]\n    (concat ;; the node itself\n            (list node)\n            ;; if we're inside another top-level node, add an edge to this node\n            (when *parent*\n              (edge ast {:src *parent* :dest (:id node)}))\n            ;; parse the body with this node as the new parent\n            (binding [*parent* (:id node)]\n              (-> (mapcat ast/parse body-asts)\n                  ;; laziness + binding = trouble, so force this sequence\n                  doall))\n            ;; if this ast included a macro expansion, add an edge to the macro\n            (when-let [dest (and (:raw-forms ast)\n                                 (ast/first-form-var ast))]\n              (edge ast {:src (:id node) :dest dest})))))","label"="phone-tree.parse.build/node"];
"phone-tree.log" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 1\n(ns phone-tree.log\n  \"Debug logging\")","label"="phone-tree.log"];
"phone-tree.log/level-map" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 6\n(def level-map\n  {:trace #{:trace :debug :warn}\n   :debug #{:debug :warn}\n   :warn #{:warn}})","label"="phone-tree.log/level-map"];
"phone-tree.log/debugf" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 33\n(def debugf (partial logf :debug))","label"="phone-tree.log/debugf"];
"phone-tree.parse.macro/*in-macro*" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/macro.clj, line 7\n(def ^:dynamic *in-macro* false)","label"="phone-tree.parse.macro/*in-macro*"];
"clojure.string/replace" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.string/replace"];
"phone-tree.parse.build/merge-attrs" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 108\n(defn merge-attrs [attr-seq]\n  (let [locations (set (keep :location attr-seq))]\n    (-> (apply clojure.core/merge attr-seq)\n        (dissoc :location)\n        (assoc :locations locations)\n        (assoc :count (count locations)))))","label"="phone-tree.parse.build/merge-attrs"];
"phone-tree.parse.build/->edge" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 67\n(defn ->edge [attrs]\n  (assoc attrs :id (str (:src attrs) \" -> \" (:dest attrs))))","label"="phone-tree.parse.build/->edge"];
"java.io.PushbackReader/." ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="java.io.PushbackReader/."];
"clojure.tools.analyzer.jvm/analyze-ns" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.analyzer.jvm/analyze-ns"];
"phone-tree.parse.build/mark-external-nodes" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 122\n(defn mark-external-nodes [g]\n  (->> (uber/nodes g)\n       (remove (comp seq :locations (partial uber/attrs g)))\n       (reduce (fn [g n] (uber/add-attr g n :external? true)) g)))","label"="phone-tree.parse.build/mark-external-nodes"];
"phone-tree.parse.var" ["fillcolor"="lightpink","style"="filled","class"="node namespace","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/var.clj, line 1\n(ns phone-tree.parse.var\n  \"Clojure var parsing (def forms and function calls).\"\n  (:require [phone-tree.parse.ast :as ast]\n            [phone-tree.parse.build :as build]\n            [phone-tree.parse.class :refer [guess-class]]))","label"="phone-tree.parse.var"];
"phone-tree.graph/->starting-nodes" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 65\n(defn- ->starting-nodes [g starting-nodes-or-fn]\n  (if (fn? starting-nodes-or-fn)\n    (filter starting-nodes-or-fn (uber/nodes g))\n    starting-nodes-or-fn))","label"="phone-tree.graph/->starting-nodes"];
"phone-tree.parse/nss->graph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse.clj, line 49\n(defn nss->graph\n  \"Returns a call graph for a number of namespaces.\"\n  [nss]\n  (build/ubergraph (mapcat parse-ns nss)))","label"="phone-tree.parse/nss->graph"];
"phone-tree.log/logf" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 25\n(defn logf\n  [level fmt & args]\n  (when (enabled? level)\n    (binding [*out* *err*]\n      (apply printf fmt args)\n      (println))))","label"="phone-tree.log/logf"];
"phone-tree.parse.ast/parse (quote clojure.core/extend)" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/protocol.clj, line 127\n(defmethod ast/parse 'clojure.core/extend\n  [{[the-cls & proto+maps] :args :as ast}]\n  ;; extend takes multiple protocols and function maps:\n  ;;\n  ;;   (extend AType\n  ;;     AProtocol\n  ;;     {:some-fn (fn [] ...)\n  ;;      ...}\n  ;;     BProtocol\n  ;;     {...})\n  ;;\n  (when-let [class-sym (some-> the-cls :val (.getName) symbol)]\n    (flatten\n     ;; 1. Outer loop -- each protocol and function map\n     (for [[protocol-var method-map] (partition-all 2 proto+maps)\n           :let [protocol (util/var->symbol (:var protocol-var))\n                 protocol-ns (some-> protocol namespace)]]\n       (cond\n         (not protocol-ns)\n         (log/warnf \"Unable to parse extend without protocol: %s\"\n                    (:form ast))\n         (not= :map (:op method-map))\n         (log/warnf \"Unable to parse extend with %s method-map: %s\"\n                    (:op method-map) (:form ast))\n         :else\n         ;; 2. Inner loop -- each k/v pair in the function map\n         (for [[fn-kw body] (map vector (:keys method-map) (:vals method-map))\n               ;; For each function:\n               ;; - ns is the protocol's namespace\n               ;; - name is the key in the function map\n               ;; - the class (to dispatch on) is the type that is being extended\n               ;; - body is the value in the function map\n               :let [protocol-fn (some->> fn-kw :val name (symbol protocol-ns))]]\n           (if-not protocol-fn\n             (log/warnf \"Unable to find protocol function in extend for %s\"\n                        (:form fn-kw))\n             ;; Unlike :method, extend doesn't add _methods_ to a type, it just\n             ;; adds _dispatches_ from the protocol. These extend functions\n             ;; exist at (get-in MyProtocol [:impls some-class :fn-kw])\n             (concat ;; the method, which dispatches on class\n                     (build/node ast\n                                 {:symbol protocol-fn, :dispatch class-sym}\n                                 body)\n                     ;; call the dispatch from the protocol-fn fn\n                     (build/edge ast {:src {:symbol protocol-fn}\n                                      :dest {:symbol protocol-fn\n                                             :dispatch class-sym}})))))))))","label"="phone-tree.parse.ast/parse (quote clojure.core/extend)"];
"clojure.tools.analyzer.jvm.utils/box" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.tools.analyzer.jvm.utils/box"];
"phone-tree.parse.class/reify-templates" ["fillcolor"="gray","style"="filled","class"="node","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/class.clj, line 20\n(def reify-templates (atom {}))","label"="phone-tree.parse.class/reify-templates"];
"phone-tree.parse.ast/parse _default" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/ast.clj, line 86\n(defmethod parse :default\n  [ast]\n  (parse-children (ana.ast/children ast)))","label"="phone-tree.parse.ast/parse :default"];
"phone-tree.html/render" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/html.clj, line 18\n(defn render [json-graph]\n  (mini-hbs (read-html-resource \"template.hbs\")\n            {:json-graph json-graph}))","label"="phone-tree.html/render"];
"phone-tree.parse.build/node-id" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 56\n(defn node-id [x]\n  (if (string? x)\n    x\n    (let [{:keys [symbol dispatch]} (conform-node x)]\n      (if dispatch\n        (str symbol \" \" (pr-str dispatch))\n        (str symbol)))))","label"="phone-tree.parse.build/node-id"];
"clojure.data.json/write-str" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.data.json/write-str"];
"phone-tree.graph/remove-nodes" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 42\n(defn remove-nodes\n  \"Removes nodes and edges given a function `f` that takes a node id.\n\n  Edges will be removed if either :src or :dest matches.\"\n  [g f]\n  (apply uber/remove-nodes g (filter f (uber/nodes g))))","label"="phone-tree.graph/remove-nodes"];
"phone-tree.parse.build/node-type clojure.lang.Fn" ["fillcolor"="lavender","style"="filled","class"="node protocol-fn","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 16\n(extend-protocol NodeType\n  clojure.lang.MultiFn\n  (node-type [_] :multimethod)\n  clojure.lang.Fn\n  (node-type [_] :function)\n  #_#_clojure.core.async.impl.protocols.Channel\n  (node-type [_] :channel)\n  java.lang.Class\n  (node-type [_] :class)\n  clojure.lang.Var\n  (node-type [v]\n    (cond\n      (:macro (meta v)) :macro\n      (:protocol (meta v)) :protocol-fn\n      :else (node-type (var-get v))))\n  clojure.lang.Symbol\n  (node-type [s]\n    (let [v (ns-resolve 'clojure.core s)]\n      (cond\n        v (node-type v)\n        (find-ns s) :namespace\n        (and (namespace s) (class? (ns-resolve 'clojure.core (symbol (namespace s))))) :method\n        :else nil)))\n  ;; Defaults\n  java.lang.Object\n  (node-type [_] nil)\n  nil\n  (node-type [_] nil))","label"="phone-tree.parse.build/node-type clojure.lang.Fn"];
"phone-tree.graph/->dot" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/graph.clj, line 160\n(defn ->dot\n  \"Returns a dot file as a string.\n\n  `attrs` are optional dot graph attributes.\"\n  ([g] (->dot g nil))\n  ([g attrs]\n   ;; this is a little hacky: ubergraph expects to write to a file, but it uses\n   ;; `spit` to write dot, so we can use a writer to get string output\n   (let [writer (java.io.StringWriter.)]\n     ;; force dorothy to quote ids and attributes\n     (with-redefs [dorothy.core/safe-id? (constantly false)]\n       (-> g\n           with-dot-attrs\n           (uber/viz-graph (assoc attrs :save {:format :dot :filename writer}))))\n     (str writer))))","label"="phone-tree.graph/->dot"];
"phone-tree.parse.ast/parse _host-interop" ["fillcolor"="lavender","style"="filled","class"="node multimethod","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/interop.clj, line 26\n(defmethod ast/parse :host-interop\n  [{:keys [m-or-f target] :as ast}]\n  (let [;; By definition, this op-code means we have no type information, but\n        ;; give it a guess anyways\n        cls (or (guess-class target)\n                (guess-class ast)\n                java.lang.Object)\n        method-sym (symbol (.getName cls) (str m-or-f))]\n    ;; By definition, this is a 0-arg function or a field, so there are no\n    ;; other child args to parse\n    (build/edge ast {:dest method-sym})))","label"="phone-tree.parse.ast/parse :host-interop"];
"phone-tree.parse.build/ubergraph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse/build.clj, line 127\n(defn ubergraph [nodes-and-edges]\n  ;; collapse multiple nodes into a single node, and multiple edges into a\n  ;; single edge, but retain each ast location in :locations\n  (->> nodes-and-edges\n       (group-by :id)\n       (vals)\n       (map merge-attrs)\n       (map attrs->ubergraph)\n       (apply uber/digraph)\n       (mark-external-nodes)))","label"="phone-tree.parse.build/ubergraph"];
"ubergraph.core/ubergraph->edn" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="ubergraph.core/ubergraph->edn"];
"loom.attr/attrs" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="loom.attr/attrs"];
"clojure.java.io/reader" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.java.io/reader"];
"phone-tree.log/enabled?" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/log.clj, line 11\n(defn enabled?\n  [level]\n  (contains? (level-map *level*) level))","label"="phone-tree.log/enabled?"];
"phone-tree.namespace/prepare-namespaces" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/namespace.clj, line 8\n(defn prepare-namespaces\n  \"First, create all of our namespaces so that we don't have to worry about\n  the order in which we load them. Then, load all of them.\"\n  [namespaces]\n  (doseq [n namespaces]\n    (create-ns n))\n  (doseq [n namespaces]\n    (require n #_:reload))\n  namespaces)","label"="phone-tree.namespace/prepare-namespaces"];
"phone-tree.parse/ast-meta->graph" ["fillcolor"="white","style"="filled","class"="node function","tooltip"="file:/Users/mike/code/phone-tree/phone-tree/src/phone_tree/parse.clj, line 61\n(defn ast-meta->graph\n  \"Returns a map of edges and nodes defined in a var's metadata.\n\n  Vars may attach the following metadata:\n\n  {:phone-tree/nodes ['symbol ...]\n   :phone-tree/edges [{:src 'symbol :dest 'symbol} ...]}\n\n  Unqualified symbols will use the current namespace.\n\n  Nodes may also be a map with :symbol and :dispatch keys for multiple-dispatch\n  functions and calls.\"\n  [ast]\n  (letfn [(qualify-symbol [x] (if (namespace x)\n                                x\n                                (symbol (-> ast :meta :ns ns-name str)\n                                        (name x))))\n          (->node [x]\n            (let [n (if (map? x) x {:symbol x})]\n              (update n :symbol qualify-symbol)))]\n    (merge\n      (when-let [edges (-> ast :meta :phone-tree/edges)]\n        {:edges (for [{:keys [caller call]} edges]\n                  {:caller (->node caller)\n                   :call (->node call)\n                   :location (ast/location ast)})})\n      (when-let [nodes (-> ast :meta :phone-tree/nodes)]\n        {:nodes (for [n (map ->node nodes)]\n                  (assoc n :location (ast/location ast)))}))))","label"="phone-tree.parse/ast-meta->graph"];
"clojure.data.csv/write-csv" ["fillcolor"="gray","style"="filled,dashed","class"="node","label"="clojure.data.csv/write-csv"];
"phone-tree.parse.ast/dispatches" -> "phone-tree.parse.ast/first-form-var" ["class"="edge","tooltip"="phone-tree.parse.ast/dispatches -> phone-tree.parse.ast/first-form-var"];
"phone-tree.parse.ast/dispatches" -> "phone-tree.util/var->symbol" ["class"="edge","tooltip"="phone-tree.parse.ast/dispatches -> phone-tree.util/var->symbol"];
"phone-tree.parse.ast/parse _reify" -> "phone-tree.parse.class/record-reify!" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :reify -> phone-tree.parse.class/record-reify!"];
"phone-tree.parse.ast/parse _reify" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :reify -> phone-tree.parse.ast/parse"];
"phone-tree.graph/read-lines" -> "clojure.string/split-lines" ["class"="edge","tooltip"="phone-tree.graph/read-lines -> clojure.string/split-lines"];
"phone-tree.graph/edge-with-attrs" -> "loom.attr/attrs" ["class"="edge","tooltip"="phone-tree.graph/edge-with-attrs -> loom.attr/attrs"];
"phone-tree.graph/edge-with-attrs" -> "loom.graph/dest" ["class"="edge","tooltip"="phone-tree.graph/edge-with-attrs -> loom.graph/dest"];
"phone-tree.graph/edge-with-attrs" -> "loom.graph/src" ["class"="edge","tooltip"="phone-tree.graph/edge-with-attrs -> loom.graph/src"];
"phone-tree.parse.ast/parse _instance-call" -> "phone-tree.parse.ast/parse-children" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :instance-call -> phone-tree.parse.ast/parse-children"];
"phone-tree.parse.ast/parse _instance-call" -> "phone-tree.parse.class/guess-class" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :instance-call -> phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _instance-call" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :instance-call -> phone-tree.parse.build/edge"];
"phone-tree.graph/node-with-attrs" -> "loom.attr/attrs" ["class"="edge","tooltip"="phone-tree.graph/node-with-attrs -> loom.attr/attrs"];
"phone-tree.log/debug" -> "phone-tree.log/log" ["class"="edge","tooltip"="phone-tree.log/debug -> phone-tree.log/log"];
"phone-tree.core/parse-cli" -> "clojure.string/join" ["class"="edge","tooltip"="phone-tree.core/parse-cli -> clojure.string/join"];
"phone-tree.core/parse-cli" -> "phone-tree.core/conform-options" ["class"="edge","tooltip"="phone-tree.core/parse-cli -> phone-tree.core/conform-options"];
"phone-tree.core/parse-cli" -> "phone-tree.core/usage" ["class"="edge","tooltip"="phone-tree.core/parse-cli -> phone-tree.core/usage"];
"phone-tree.core/parse-cli" -> "clojure.tools.cli/parse-opts" ["class"="edge","tooltip"="phone-tree.core/parse-cli -> clojure.tools.cli/parse-opts"];
"phone-tree.core/parse-cli" -> "phone-tree.core/cli-options" ["class"="edge","tooltip"="phone-tree.core/parse-cli -> phone-tree.core/cli-options"];
"phone-tree.core/print-graph" -> "phone-tree.graph/->csv" ["class"="edge","tooltip"="phone-tree.core/print-graph -> phone-tree.graph/->csv"];
"phone-tree.core/print-graph" -> "phone-tree.graph/->json" ["class"="edge","tooltip"="phone-tree.core/print-graph -> phone-tree.graph/->json"];
"phone-tree.core/print-graph" -> "phone-tree.html/render" ["class"="edge","tooltip"="phone-tree.core/print-graph -> phone-tree.html/render"];
"phone-tree.core/print-graph" -> "phone-tree.graph/->dot" ["class"="edge","tooltip"="phone-tree.core/print-graph -> phone-tree.graph/->dot"];
"phone-tree.core/print-graph" -> "ubergraph.core/ubergraph->edn" ["class"="edge","tooltip"="phone-tree.core/print-graph -> ubergraph.core/ubergraph->edn"];
"phone-tree.parse.ast/parse _static-call" -> "phone-tree.parse.ast/parse-children" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :static-call -> phone-tree.parse.ast/parse-children"];
"phone-tree.parse.ast/parse _static-call" -> "phone-tree.parse.class/guess-class" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :static-call -> phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _static-call" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :static-call -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse-children" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse.ast/parse-children -> phone-tree.parse.ast/parse"];
"phone-tree.core/conform-options" -> "phone-tree.core/exclude-clojure-regex" ["class"="edge","tooltip"="phone-tree.core/conform-options -> phone-tree.core/exclude-clojure-regex"];
"phone-tree.core/conform-options" -> "phone-tree.core/exclude-java-regex" ["class"="edge","tooltip"="phone-tree.core/conform-options -> phone-tree.core/exclude-java-regex"];
"phone-tree.core/usage" -> "clojure.string/join" ["class"="edge","tooltip"="phone-tree.core/usage -> clojure.string/join"];
"phone-tree.parse.ast/parse (quote clojure.core/defprotocol)" -> "phone-tree.parse.ast/ast-resolve" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defprotocol) -> phone-tree.parse.ast/ast-resolve"];
"phone-tree.parse.ast/parse (quote clojure.core/defprotocol)" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defprotocol) -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse (quote clojure.core/defprotocol)" -> "phone-tree.util/var->symbol" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defprotocol) -> phone-tree.util/var->symbol"];
"phone-tree.parse.ast/parse (quote clojure.core/defprotocol)" -> "phone-tree.parse.build/node" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defprotocol) -> phone-tree.parse.build/node"];
"phone-tree.redef/redef-form" -> "phone-tree.redef/try-require" ["class"="edge","tooltip"="phone-tree.redef/redef-form -> phone-tree.redef/try-require"];
"phone-tree.redef/redef-form" -> "phone-tree.log/warnf" ["class"="edge","tooltip"="phone-tree.redef/redef-form -> phone-tree.log/warnf"];
"phone-tree.redef/redef-form" -> "phone-tree.log/debugf" ["class"="edge","tooltip"="phone-tree.redef/redef-form -> phone-tree.log/debugf"];
"phone-tree.graph/sanitize-id" -> "clojure.string/replace" ["class"="edge","tooltip"="phone-tree.graph/sanitize-id -> clojure.string/replace"];
"phone-tree.graph/collapse" -> "ubergraph.core/node-with-attrs" ["class"="edge","tooltip"="phone-tree.graph/collapse -> ubergraph.core/node-with-attrs"];
"phone-tree.graph/collapse" -> "loom.graph/successors" ["class"="edge","tooltip"="phone-tree.graph/collapse -> loom.graph/successors"];
"phone-tree.graph/collapse" -> "phone-tree.graph/reachable-nodes" ["class"="edge","tooltip"="phone-tree.graph/collapse -> phone-tree.graph/reachable-nodes"];
"phone-tree.graph/collapse" -> "ubergraph.protocols/find-edge" ["class"="edge","tooltip"="phone-tree.graph/collapse -> ubergraph.protocols/find-edge"];
"phone-tree.graph/collapse" -> "ubergraph.core/digraph" ["class"="edge","tooltip"="phone-tree.graph/collapse -> ubergraph.core/digraph"];
"phone-tree.graph/collapse" -> "phone-tree.graph/->starting-nodes" ["class"="edge","tooltip"="phone-tree.graph/collapse -> phone-tree.graph/->starting-nodes"];
"phone-tree.core/collect-fn" -> "phone-tree.core/collect-val" ["class"="edge","tooltip"="phone-tree.core/collect-fn -> phone-tree.core/collect-val"];
"phone-tree.parse.ast/first-form-var" -> "phone-tree.parse.ast/ast-resolve" ["class"="edge","tooltip"="phone-tree.parse.ast/first-form-var -> phone-tree.parse.ast/ast-resolve"];
"phone-tree.parse.ast/first-form-var" -> "phone-tree.parse.ast/form" ["class"="edge","tooltip"="phone-tree.parse.ast/first-form-var -> phone-tree.parse.ast/form"];
"phone-tree.core/-main" -> "phone-tree.core/run" ["class"="edge","tooltip"="phone-tree.core/-main -> phone-tree.core/run"];
"phone-tree.core/-main" -> "phone-tree.core/parse-cli" ["class"="edge","tooltip"="phone-tree.core/-main -> phone-tree.core/parse-cli"];
"phone-tree.parse.class/guess-class" -> "phone-tree.parse.class/guess-class*" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class -> phone-tree.parse.class/guess-class*"];
"phone-tree.parse.class/guess-class" -> "phone-tree.parse.class/guess-class" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class -> phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _method" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :method -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse _method" -> "phone-tree.parse.protocol/default-record-method?" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :method -> phone-tree.parse.protocol/default-record-method?"];
"phone-tree.parse.ast/parse _method" -> "phone-tree.parse.build/node" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :method -> phone-tree.parse.build/node"];
"phone-tree.graph/tooltip" -> "clojure.string/join" ["class"="edge","tooltip"="phone-tree.graph/tooltip -> clojure.string/join"];
"phone-tree.graph/tooltip" -> "phone-tree.graph/form" ["class"="edge","tooltip"="phone-tree.graph/tooltip -> phone-tree.graph/form"];
"phone-tree.graph/tooltip" -> "clojure.string/blank?" ["class"="edge","tooltip"="phone-tree.graph/tooltip -> clojure.string/blank?"];
"phone-tree.parse.build/node-type clojure.lang.Symbol" -> "phone-tree.parse.build/node-type" ["class"="edge","tooltip"="phone-tree.parse.build/node-type clojure.lang.Symbol -> phone-tree.parse.build/node-type"];
"phone-tree.graph/form" -> "phone-tree.graph/read-lines" ["class"="edge","tooltip"="phone-tree.graph/form -> phone-tree.graph/read-lines"];
"phone-tree.graph/form" -> "clojure.string/join" ["class"="edge","tooltip"="phone-tree.graph/form -> clojure.string/join"];
"phone-tree.graph/digraph" -> "loom.graph/add-edges" ["class"="edge","tooltip"="phone-tree.graph/digraph -> loom.graph/add-edges"];
"phone-tree.graph/digraph" -> "loom.graph/digraph" ["class"="edge","tooltip"="phone-tree.graph/digraph -> loom.graph/digraph"];
"phone-tree.graph/digraph" -> "phone-tree.graph/merge-attrs" ["class"="edge","tooltip"="phone-tree.graph/digraph -> phone-tree.graph/merge-attrs"];
"phone-tree.graph/digraph" -> "loom.graph/add-nodes" ["class"="edge","tooltip"="phone-tree.graph/digraph -> loom.graph/add-nodes"];
"phone-tree.graph/filter-ancestors" -> "phone-tree.graph/->starting-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-ancestors -> phone-tree.graph/->starting-nodes"];
"phone-tree.graph/filter-ancestors" -> "phone-tree.graph/filter-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-ancestors -> phone-tree.graph/filter-nodes"];
"phone-tree.graph/filter-ancestors" -> "loom.graph/predecessors" ["class"="edge","tooltip"="phone-tree.graph/filter-ancestors -> loom.graph/predecessors"];
"phone-tree.graph/filter-ancestors" -> "phone-tree.graph/reachable-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-ancestors -> phone-tree.graph/reachable-nodes"];
"phone-tree.graph/merge-attrs" -> "loom.attr/add-attr" ["class"="edge","tooltip"="phone-tree.graph/merge-attrs -> loom.attr/add-attr"];
"phone-tree.html/mini-hbs" -> "phone-tree.html/read-html-resource" ["class"="edge","tooltip"="phone-tree.html/mini-hbs -> phone-tree.html/read-html-resource"];
"phone-tree.html/mini-hbs" -> "clojure.string/replace" ["class"="edge","tooltip"="phone-tree.html/mini-hbs -> clojure.string/replace"];
"phone-tree.graph/filter-descendants" -> "loom.graph/successors" ["class"="edge","tooltip"="phone-tree.graph/filter-descendants -> loom.graph/successors"];
"phone-tree.graph/filter-descendants" -> "phone-tree.graph/reachable-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-descendants -> phone-tree.graph/reachable-nodes"];
"phone-tree.graph/filter-descendants" -> "phone-tree.graph/filter-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-descendants -> phone-tree.graph/filter-nodes"];
"phone-tree.graph/filter-descendants" -> "phone-tree.graph/->starting-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-descendants -> phone-tree.graph/->starting-nodes"];
"phone-tree.graph/->csv" -> "phone-tree.graph/->topology" ["class"="edge","tooltip"="phone-tree.graph/->csv -> phone-tree.graph/->topology"];
"phone-tree.graph/->csv" -> "clojure.data.csv/write-csv" ["class"="edge","tooltip"="phone-tree.graph/->csv -> clojure.data.csv/write-csv"];
"phone-tree.graph/->csv" -> "java.io.StringWriter/." ["class"="edge","tooltip"="phone-tree.graph/->csv -> java.io.StringWriter/."];
"phone-tree.log/warnf" -> "phone-tree.log/logf" ["class"="edge","tooltip"="phone-tree.log/warnf -> phone-tree.log/logf"];
"phone-tree.parse.build/node-type" -> "phone_tree.parse.build.NodeType/node_type" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone_tree.parse.build.NodeType/node_type"];
"phone-tree.parse.build/node-type" -> "phone-tree.parse.build/node-type clojure.lang.MultiFn" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone-tree.parse.build/node-type clojure.lang.MultiFn"];
"phone-tree.parse.build/node-type" -> "phone-tree.parse.build/node-type clojure.lang.Symbol" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone-tree.parse.build/node-type clojure.lang.Symbol"];
"phone-tree.parse.build/node-type" -> "phone-tree.parse.build/node-type clojure.lang.Fn" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone-tree.parse.build/node-type clojure.lang.Fn"];
"phone-tree.parse.build/node-type" -> "phone-tree.parse.build/node-type clojure.lang.Var" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone-tree.parse.build/node-type clojure.lang.Var"];
"phone-tree.parse.build/node-type" -> "phone-tree.parse.build/node-type java.lang.Class" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone-tree.parse.build/node-type java.lang.Class"];
"phone-tree.parse.build/node-type" -> "phone-tree.parse.build/node-type java.lang.Object" ["class"="edge","tooltip"="phone-tree.parse.build/node-type -> phone-tree.parse.build/node-type java.lang.Object"];
"phone-tree.core/prune-graph" -> "phone-tree.graph/collapse" ["class"="edge","tooltip"="phone-tree.core/prune-graph -> phone-tree.graph/collapse"];
"phone-tree.core/prune-graph" -> "phone-tree.graph/filter-ancestors" ["class"="edge","tooltip"="phone-tree.core/prune-graph -> phone-tree.graph/filter-ancestors"];
"phone-tree.core/prune-graph" -> "phone-tree.graph/filter-descendants" ["class"="edge","tooltip"="phone-tree.core/prune-graph -> phone-tree.graph/filter-descendants"];
"phone-tree.core/prune-graph" -> "phone-tree.core/matches-any?" ["class"="edge","tooltip"="phone-tree.core/prune-graph -> phone-tree.core/matches-any?"];
"phone-tree.core/prune-graph" -> "phone-tree.graph/filter-nodes" ["class"="edge","tooltip"="phone-tree.core/prune-graph -> phone-tree.graph/filter-nodes"];
"phone-tree.core/prune-graph" -> "phone-tree.graph/remove-nodes" ["class"="edge","tooltip"="phone-tree.core/prune-graph -> phone-tree.graph/remove-nodes"];
"phone-tree.core/run-with-project" -> "phone-tree.core/parse-cli" ["class"="edge","tooltip"="phone-tree.core/run-with-project -> phone-tree.core/parse-cli"];
"phone-tree.core/run-with-project" -> "phone-tree.core/run" ["class"="edge","tooltip"="phone-tree.core/run-with-project -> phone-tree.core/run"];
"phone-tree.redef/read-forms" -> "java.io.Reader/close" ["class"="edge","tooltip"="phone-tree.redef/read-forms -> java.io.Reader/close"];
"phone-tree.redef/read-forms" -> "java.io.PushbackReader/." ["class"="edge","tooltip"="phone-tree.redef/read-forms -> java.io.PushbackReader/."];
"phone-tree.redef/read-forms" -> "clojure.java.io/reader" ["class"="edge","tooltip"="phone-tree.redef/read-forms -> clojure.java.io/reader"];
"phone-tree.namespace/nss-in-dirs" -> "clojure.tools.namespace.dir/scan-all" ["class"="edge","tooltip"="phone-tree.namespace/nss-in-dirs -> clojure.tools.namespace.dir/scan-all"];
"phone-tree.namespace/nss-in-dirs" -> "clojure.tools.namespace.track/tracker" ["class"="edge","tooltip"="phone-tree.namespace/nss-in-dirs -> clojure.tools.namespace.track/tracker"];
"phone-tree.parse.build/edge" -> "phone-tree.parse.build/*parent*" ["class"="edge","tooltip"="phone-tree.parse.build/edge -> phone-tree.parse.build/*parent*"];
"phone-tree.parse.build/edge" -> "phone-tree.parse.ast/location" ["class"="edge","tooltip"="phone-tree.parse.build/edge -> phone-tree.parse.ast/location"];
"phone-tree.parse.build/edge" -> "phone-tree.log/tracef" ["class"="edge","tooltip"="phone-tree.parse.build/edge -> phone-tree.log/tracef"];
"phone-tree.parse.build/edge" -> "phone-tree.parse.build/->edge" ["class"="edge","tooltip"="phone-tree.parse.build/edge -> phone-tree.parse.build/->edge"];
"phone-tree.parse.build/edge" -> "phone-tree.parse.build/node-id" ["class"="edge","tooltip"="phone-tree.parse.build/edge -> phone-tree.parse.build/node-id"];
"phone-tree.parse.ast/parse _quote" -> "phone-tree.parse.ast/parse-children" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :quote -> phone-tree.parse.ast/parse-children"];
"phone-tree.parse.ast/parse _quote" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :quote -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse _quote" -> "phone-tree.parse.macro/*in-macro*" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :quote -> phone-tree.parse.macro/*in-macro*"];
"phone-tree.parse.ast/parse _var" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :var -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse-dispatch" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse.ast/parse-dispatch -> phone-tree.parse.ast/parse"];
"phone-tree.parse.ast/parse-dispatch" -> "phone-tree.parse.ast/dispatches" ["class"="edge","tooltip"="phone-tree.parse.ast/parse-dispatch -> phone-tree.parse.ast/dispatches"];
"phone-tree.parse.protocol/protocol-dispatch" -> "clojure.tools.analyzer.jvm.utils/box" ["class"="edge","tooltip"="phone-tree.parse.protocol/protocol-dispatch -> clojure.tools.analyzer.jvm.utils/box"];
"phone-tree.parse.protocol/protocol-dispatch" -> "phone-tree.parse.protocol/super-chain" ["class"="edge","tooltip"="phone-tree.parse.protocol/protocol-dispatch -> phone-tree.parse.protocol/super-chain"];
"phone-tree.parse.build/->node" -> "phone-tree.parse.build/node-id" ["class"="edge","tooltip"="phone-tree.parse.build/->node -> phone-tree.parse.build/node-id"];
"phone-tree.parse.class/guess-class*" -> "phone-tree.parse.class/guess-class* _var" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class* -> phone-tree.parse.class/guess-class* :var"];
"phone-tree.parse.class/guess-class*" -> "phone-tree.parse.class/guess-class* _default" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class* -> phone-tree.parse.class/guess-class* :default"];
"phone-tree.parse.class/guess-class*" -> "phone-tree.parse.class/guess-class* _const" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class* -> phone-tree.parse.class/guess-class* :const"];
"phone-tree.html/read-html-resource" -> "clojure.java.io/resource" ["class"="edge","tooltip"="phone-tree.html/read-html-resource -> clojure.java.io/resource"];
"phone-tree.parse.ast/parse _protocol-invoke" -> "phone-tree.parse.class/guess-class" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :protocol-invoke -> phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _protocol-invoke" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :protocol-invoke -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse _protocol-invoke" -> "phone-tree.parse.protocol/protocol-dispatch" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :protocol-invoke -> phone-tree.parse.protocol/protocol-dispatch"];
"phone-tree.parse.ast/parse _protocol-invoke" -> "phone-tree.util/var->symbol" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :protocol-invoke -> phone-tree.util/var->symbol"];
"phone-tree.parse.ast/parse _protocol-invoke" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :protocol-invoke -> phone-tree.parse.ast/parse"];
"phone-tree.parse.class/record-reify!" -> "phone-tree.parse.class/reify-templates" ["class"="edge","tooltip"="phone-tree.parse.class/record-reify! -> phone-tree.parse.class/reify-templates"];
"phone-tree.parse.class/record-reify!" -> "phone-tree.parse.class/reify-prefix" ["class"="edge","tooltip"="phone-tree.parse.class/record-reify! -> phone-tree.parse.class/reify-prefix"];
"phone-tree.parse.class/guess-class* _const" -> "phone-tree.log/debugf" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class* :const -> phone-tree.log/debugf"];
"phone-tree.parse.protocol/super-chain" -> "phone-tree.parse.protocol/super-chain" ["class"="edge","tooltip"="phone-tree.parse.protocol/super-chain -> phone-tree.parse.protocol/super-chain"];
"phone-tree.parse.protocol/default-record-methods" -> "clojure.tools.analyzer.ast/nodes" ["class"="edge","tooltip"="phone-tree.parse.protocol/default-record-methods -> clojure.tools.analyzer.ast/nodes"];
"phone-tree.parse.protocol/default-record-methods" -> "clojure.tools.analyzer.jvm/analyze" ["class"="edge","tooltip"="phone-tree.parse.protocol/default-record-methods -> clojure.tools.analyzer.jvm/analyze"];
"phone-tree.log/warn" -> "phone-tree.log/log" ["class"="edge","tooltip"="phone-tree.log/warn -> phone-tree.log/log"];
"phone-tree.graph/edge-attrs" -> "loom.graph/src" ["class"="edge","tooltip"="phone-tree.graph/edge-attrs -> loom.graph/src"];
"phone-tree.graph/edge-attrs" -> "loom.graph/dest" ["class"="edge","tooltip"="phone-tree.graph/edge-attrs -> loom.graph/dest"];
"phone-tree.parse.ast/parse _the-var" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :the-var -> phone-tree.parse.build/edge"];
"phone-tree.redef/load-redefs" -> "phone-tree.redef/read-forms" ["class"="edge","tooltip"="phone-tree.redef/load-redefs -> phone-tree.redef/read-forms"];
"phone-tree.redef/load-redefs" -> "phone-tree.redef/redef-form" ["class"="edge","tooltip"="phone-tree.redef/load-redefs -> phone-tree.redef/redef-form"];
"phone-tree.redef/load-redefs" -> "phone-tree.log/debugf" ["class"="edge","tooltip"="phone-tree.redef/load-redefs -> phone-tree.log/debugf"];
"phone-tree.parse.class/guess-class* _var" -> "phone-tree.parse.class/reify-class" ["class"="edge","tooltip"="phone-tree.parse.class/guess-class* :var -> phone-tree.parse.class/reify-class"];
"phone-tree.graph/->topology" -> "loom.attr/attr" ["class"="edge","tooltip"="phone-tree.graph/->topology -> loom.attr/attr"];
"phone-tree.graph/->topology" -> "loom.graph/src" ["class"="edge","tooltip"="phone-tree.graph/->topology -> loom.graph/src"];
"phone-tree.graph/->topology" -> "loom.graph/dest" ["class"="edge","tooltip"="phone-tree.graph/->topology -> loom.graph/dest"];
"phone-tree.graph/->topology" -> "loom.graph/edges" ["class"="edge","tooltip"="phone-tree.graph/->topology -> loom.graph/edges"];
"phone-tree.parse.ast/parse (quote clojure.core/in-ns)" -> "phone-tree.parse.build/node" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/in-ns) -> phone-tree.parse.build/node"];
"phone-tree.core/cli-options" -> "phone-tree.core/collect-fn" ["class"="edge","tooltip"="phone-tree.core/cli-options -> phone-tree.core/collect-fn"];
"phone-tree.core/cli-options" -> "clojure.string/split" ["class"="edge","tooltip"="phone-tree.core/cli-options -> clojure.string/split"];
"phone-tree.parse.ast/parse _def" -> "phone-tree.parse.build/node" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :def -> phone-tree.parse.build/node"];
"phone-tree.parse.ast/parse _new" -> "phone-tree.parse.ast/parse-children" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :new -> phone-tree.parse.ast/parse-children"];
"phone-tree.parse.ast/parse _new" -> "phone-tree.parse.class/guess-class" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :new -> phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _new" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :new -> phone-tree.parse.build/edge"];
"phone-tree.parse/parse-ns" -> "phone-tree.log/debugf" ["class"="edge","tooltip"="phone-tree.parse/parse-ns -> phone-tree.log/debugf"];
"phone-tree.parse/parse-ns" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse/parse-ns -> phone-tree.parse.ast/parse"];
"phone-tree.parse/parse-ns" -> "clojure.tools.analyzer.jvm/analyze-ns" ["class"="edge","tooltip"="phone-tree.parse/parse-ns -> clojure.tools.analyzer.jvm/analyze-ns"];
"phone-tree.log/log" -> "phone-tree.log/enabled?" ["class"="edge","tooltip"="phone-tree.log/log -> phone-tree.log/enabled?"];
"phone-tree.graph/reachable-nodes" -> "loom.alg-generic/bf-traverse" ["class"="edge","tooltip"="phone-tree.graph/reachable-nodes -> loom.alg-generic/bf-traverse"];
"phone-tree.parse/ns->graph" -> "phone-tree.parse/parse-ns" ["class"="edge","tooltip"="phone-tree.parse/ns->graph -> phone-tree.parse/parse-ns"];
"phone-tree.parse/ns->graph" -> "phone-tree.parse.build/ubergraph" ["class"="edge","tooltip"="phone-tree.parse/ns->graph -> phone-tree.parse.build/ubergraph"];
"phone-tree.parse.protocol/default-record-method?" -> "phone-tree.parse.protocol/default-record-methods" ["class"="edge","tooltip"="phone-tree.parse.protocol/default-record-method? -> phone-tree.parse.protocol/default-record-methods"];
"phone-tree.parse.protocol/default-record-method?" -> "phone-tree.parse.protocol/record-class?" ["class"="edge","tooltip"="phone-tree.parse.protocol/default-record-method? -> phone-tree.parse.protocol/record-class?"];
"phone-tree.core/run" -> "phone-tree.core/print-graph" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.core/print-graph"];
"phone-tree.core/run" -> "phone-tree.core/prune-graph" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.core/prune-graph"];
"phone-tree.core/run" -> "phone-tree.log/*level*" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.log/*level*"];
"phone-tree.core/run" -> "phone-tree.core/find-namespaces" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.core/find-namespaces"];
"phone-tree.core/run" -> "phone-tree.log/debugf" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.log/debugf"];
"phone-tree.core/run" -> "phone-tree.parse/nss->graph" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.parse/nss->graph"];
"phone-tree.core/run" -> "phone-tree.namespace/prepare-namespaces" ["class"="edge","tooltip"="phone-tree.core/run -> phone-tree.namespace/prepare-namespaces"];
"phone-tree.parse.build/node-type clojure.lang.Var" -> "phone-tree.parse.build/node-type" ["class"="edge","tooltip"="phone-tree.parse.build/node-type clojure.lang.Var -> phone-tree.parse.build/node-type"];
"phone-tree.graph/filter-nodes" -> "phone-tree.graph/remove-nodes" ["class"="edge","tooltip"="phone-tree.graph/filter-nodes -> phone-tree.graph/remove-nodes"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _reify" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :reify"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _instance-call" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :instance-call"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _static-call" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :static-call"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse (quote clojure.core/defprotocol)" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse (quote clojure.core/defprotocol)"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _method" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :method"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _quote" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :quote"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _var" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :var"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse-dispatch" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse-dispatch"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _protocol-invoke" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :protocol-invoke"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _the-var" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :the-var"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse (quote clojure.core/in-ns)" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse (quote clojure.core/in-ns)"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _def" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :def"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _new" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :new"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod)" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod)"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse (quote clojure.core/defmacro)" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse (quote clojure.core/defmacro)"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse (quote clojure.core/extend)" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse (quote clojure.core/extend)"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _default" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :default"];
"phone-tree.parse.ast/parse" -> "phone-tree.parse.ast/parse _host-interop" ["class"="edge","tooltip"="phone-tree.parse.ast/parse -> phone-tree.parse.ast/parse :host-interop"];
"phone-tree.log/trace" -> "phone-tree.log/log" ["class"="edge","tooltip"="phone-tree.log/trace -> phone-tree.log/log"];
"phone-tree.graph/->json" -> "loom.graph/nodes" ["class"="edge","tooltip"="phone-tree.graph/->json -> loom.graph/nodes"];
"phone-tree.graph/->json" -> "loom.graph/src" ["class"="edge","tooltip"="phone-tree.graph/->json -> loom.graph/src"];
"phone-tree.graph/->json" -> "loom.graph/edges" ["class"="edge","tooltip"="phone-tree.graph/->json -> loom.graph/edges"];
"phone-tree.graph/->json" -> "phone-tree.graph/with-dot-attrs" ["class"="edge","tooltip"="phone-tree.graph/->json -> phone-tree.graph/with-dot-attrs"];
"phone-tree.graph/->json" -> "loom.graph/dest" ["class"="edge","tooltip"="phone-tree.graph/->json -> loom.graph/dest"];
"phone-tree.graph/->json" -> "clojure.data.json/write-str" ["class"="edge","tooltip"="phone-tree.graph/->json -> clojure.data.json/write-str"];
"phone-tree.graph/->json" -> "loom.attr/attrs" ["class"="edge","tooltip"="phone-tree.graph/->json -> loom.attr/attrs"];
"phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod)" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod) -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod)" -> "phone-tree.parse.build/node" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.lang.MultiFn/addMethod) -> phone-tree.parse.build/node"];
"phone-tree.graph/with-dot-attrs" -> "loom.graph/nodes" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> loom.graph/nodes"];
"phone-tree.graph/with-dot-attrs" -> "phone-tree.graph/sanitize-id" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> phone-tree.graph/sanitize-id"];
"phone-tree.graph/with-dot-attrs" -> "loom.graph/src" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> loom.graph/src"];
"phone-tree.graph/with-dot-attrs" -> "phone-tree.graph/edge-attrs" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> phone-tree.graph/edge-attrs"];
"phone-tree.graph/with-dot-attrs" -> "loom.graph/edges" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> loom.graph/edges"];
"phone-tree.graph/with-dot-attrs" -> "ubergraph.core/digraph" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> ubergraph.core/digraph"];
"phone-tree.graph/with-dot-attrs" -> "loom.graph/dest" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> loom.graph/dest"];
"phone-tree.graph/with-dot-attrs" -> "phone-tree.graph/node-attrs" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> phone-tree.graph/node-attrs"];
"phone-tree.graph/with-dot-attrs" -> "loom.attr/attrs" ["class"="edge","tooltip"="phone-tree.graph/with-dot-attrs -> loom.attr/attrs"];
"phone-tree.parse.build/conform-node" -> "phone-tree.parse.build/node-type" ["class"="edge","tooltip"="phone-tree.parse.build/conform-node -> phone-tree.parse.build/node-type"];
"phone-tree.parse.build/conform-node" -> "phone-tree.util/var->symbol" ["class"="edge","tooltip"="phone-tree.parse.build/conform-node -> phone-tree.util/var->symbol"];
"phone-tree.log/tracef" -> "phone-tree.log/logf" ["class"="edge","tooltip"="phone-tree.log/tracef -> phone-tree.log/logf"];
"phone-tree.parse.ast/parse (quote clojure.core/defmacro)" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defmacro) -> phone-tree.parse.ast/parse"];
"phone-tree.parse.ast/parse (quote clojure.core/defmacro)" -> "clojure.tools.analyzer.ast/nodes" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defmacro) -> clojure.tools.analyzer.ast/nodes"];
"phone-tree.parse.ast/parse (quote clojure.core/defmacro)" -> "phone-tree.parse.macro/*in-macro*" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/defmacro) -> phone-tree.parse.macro/*in-macro*"];
"phone-tree.parse.class/reify-class" -> "phone-tree.parse.class/reify-templates" ["class"="edge","tooltip"="phone-tree.parse.class/reify-class -> phone-tree.parse.class/reify-templates"];
"phone-tree.parse.class/reify-class" -> "phone-tree.parse.class/reify-prefix" ["class"="edge","tooltip"="phone-tree.parse.class/reify-class -> phone-tree.parse.class/reify-prefix"];
"phone-tree.core/find-namespaces" -> "phone-tree.core/matches-any?" ["class"="edge","tooltip"="phone-tree.core/find-namespaces -> phone-tree.core/matches-any?"];
"phone-tree.core/find-namespaces" -> "phone-tree.namespace/nss-in-dirs" ["class"="edge","tooltip"="phone-tree.core/find-namespaces -> phone-tree.namespace/nss-in-dirs"];
"phone-tree.graph/node-attrs" -> "phone-tree.graph/tooltip" ["class"="edge","tooltip"="phone-tree.graph/node-attrs -> phone-tree.graph/tooltip"];
"phone-tree.graph/node-attrs" -> "ubergraph.core/escape-label" ["class"="edge","tooltip"="phone-tree.graph/node-attrs -> ubergraph.core/escape-label"];
"phone-tree.graph/node-attrs" -> "clojure.string/replace" ["class"="edge","tooltip"="phone-tree.graph/node-attrs -> clojure.string/replace"];
"phone-tree.parse.build/node" -> "phone-tree.parse.ast/first-form-var" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.ast/first-form-var"];
"phone-tree.parse.build/node" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.build/edge"];
"phone-tree.parse.build/node" -> "phone-tree.parse.build/*parent*" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.build/*parent*"];
"phone-tree.parse.build/node" -> "phone-tree.parse.build/->node" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.build/->node"];
"phone-tree.parse.build/node" -> "phone-tree.parse.ast/location" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.ast/location"];
"phone-tree.parse.build/node" -> "phone-tree.parse.ast/parse" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.ast/parse"];
"phone-tree.parse.build/node" -> "phone-tree.parse.build/conform-node" ["class"="edge","tooltip"="phone-tree.parse.build/node -> phone-tree.parse.build/conform-node"];
"phone-tree.log/debugf" -> "phone-tree.log/logf" ["class"="edge","tooltip"="phone-tree.log/debugf -> phone-tree.log/logf"];
"phone-tree.parse.build/mark-external-nodes" -> "loom.graph/nodes" ["class"="edge","tooltip"="phone-tree.parse.build/mark-external-nodes -> loom.graph/nodes"];
"phone-tree.parse.build/mark-external-nodes" -> "loom.attr/add-attr" ["class"="edge","tooltip"="phone-tree.parse.build/mark-external-nodes -> loom.attr/add-attr"];
"phone-tree.parse.build/mark-external-nodes" -> "loom.attr/attrs" ["class"="edge","tooltip"="phone-tree.parse.build/mark-external-nodes -> loom.attr/attrs"];
"phone-tree.graph/->starting-nodes" -> "loom.graph/nodes" ["class"="edge","tooltip"="phone-tree.graph/->starting-nodes -> loom.graph/nodes"];
"phone-tree.parse/nss->graph" -> "phone-tree.parse.build/ubergraph" ["class"="edge","tooltip"="phone-tree.parse/nss->graph -> phone-tree.parse.build/ubergraph"];
"phone-tree.parse/nss->graph" -> "phone-tree.parse/parse-ns" ["class"="edge","tooltip"="phone-tree.parse/nss->graph -> phone-tree.parse/parse-ns"];
"phone-tree.log/logf" -> "phone-tree.log/enabled?" ["class"="edge","tooltip"="phone-tree.log/logf -> phone-tree.log/enabled?"];
"phone-tree.parse.ast/parse (quote clojure.core/extend)" -> "phone-tree.log/warnf" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/extend) -> phone-tree.log/warnf"];
"phone-tree.parse.ast/parse (quote clojure.core/extend)" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/extend) -> phone-tree.parse.build/edge"];
"phone-tree.parse.ast/parse (quote clojure.core/extend)" -> "phone-tree.util/var->symbol" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/extend) -> phone-tree.util/var->symbol"];
"phone-tree.parse.ast/parse (quote clojure.core/extend)" -> "phone-tree.parse.build/node" ["class"="edge","tooltip"="phone-tree.parse.ast/parse (quote clojure.core/extend) -> phone-tree.parse.build/node"];
"phone-tree.parse.ast/parse _default" -> "clojure.tools.analyzer.ast/children" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :default -> clojure.tools.analyzer.ast/children"];
"phone-tree.parse.ast/parse _default" -> "phone-tree.parse.ast/parse-children" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :default -> phone-tree.parse.ast/parse-children"];
"phone-tree.html/render" -> "phone-tree.html/mini-hbs" ["class"="edge","tooltip"="phone-tree.html/render -> phone-tree.html/mini-hbs"];
"phone-tree.html/render" -> "phone-tree.html/read-html-resource" ["class"="edge","tooltip"="phone-tree.html/render -> phone-tree.html/read-html-resource"];
"phone-tree.parse.build/node-id" -> "phone-tree.parse.build/conform-node" ["class"="edge","tooltip"="phone-tree.parse.build/node-id -> phone-tree.parse.build/conform-node"];
"phone-tree.graph/remove-nodes" -> "loom.graph/remove-nodes" ["class"="edge","tooltip"="phone-tree.graph/remove-nodes -> loom.graph/remove-nodes"];
"phone-tree.graph/remove-nodes" -> "loom.graph/nodes" ["class"="edge","tooltip"="phone-tree.graph/remove-nodes -> loom.graph/nodes"];
"phone-tree.graph/->dot" -> "ubergraph.core/viz-graph" ["class"="edge","tooltip"="phone-tree.graph/->dot -> ubergraph.core/viz-graph"];
"phone-tree.graph/->dot" -> "dorothy.core/safe-id?" ["class"="edge","tooltip"="phone-tree.graph/->dot -> dorothy.core/safe-id?"];
"phone-tree.graph/->dot" -> "java.io.StringWriter/." ["class"="edge","tooltip"="phone-tree.graph/->dot -> java.io.StringWriter/."];
"phone-tree.graph/->dot" -> "phone-tree.graph/with-dot-attrs" ["class"="edge","tooltip"="phone-tree.graph/->dot -> phone-tree.graph/with-dot-attrs"];
"phone-tree.graph/->dot" -> "phone-tree.graph/->dot" ["class"="edge","tooltip"="phone-tree.graph/->dot -> phone-tree.graph/->dot"];
"phone-tree.parse.ast/parse _host-interop" -> "phone-tree.parse.class/guess-class" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :host-interop -> phone-tree.parse.class/guess-class"];
"phone-tree.parse.ast/parse _host-interop" -> "phone-tree.parse.build/edge" ["class"="edge","tooltip"="phone-tree.parse.ast/parse :host-interop -> phone-tree.parse.build/edge"];
"phone-tree.parse.build/ubergraph" -> "phone-tree.parse.build/attrs->ubergraph" ["class"="edge","tooltip"="phone-tree.parse.build/ubergraph -> phone-tree.parse.build/attrs->ubergraph"];
"phone-tree.parse.build/ubergraph" -> "ubergraph.core/digraph" ["class"="edge","tooltip"="phone-tree.parse.build/ubergraph -> ubergraph.core/digraph"];
"phone-tree.parse.build/ubergraph" -> "phone-tree.parse.build/merge-attrs" ["class"="edge","tooltip"="phone-tree.parse.build/ubergraph -> phone-tree.parse.build/merge-attrs"];
"phone-tree.parse.build/ubergraph" -> "phone-tree.parse.build/mark-external-nodes" ["class"="edge","tooltip"="phone-tree.parse.build/ubergraph -> phone-tree.parse.build/mark-external-nodes"];
"phone-tree.log/enabled?" -> "phone-tree.log/*level*" ["class"="edge","tooltip"="phone-tree.log/enabled? -> phone-tree.log/*level*"];
"phone-tree.log/enabled?" -> "phone-tree.log/level-map" ["class"="edge","tooltip"="phone-tree.log/enabled? -> phone-tree.log/level-map"];
"phone-tree.parse/ast-meta->graph" -> "phone-tree.parse.ast/location" ["class"="edge","tooltip"="phone-tree.parse/ast-meta->graph -> phone-tree.parse.ast/location"];
} 
